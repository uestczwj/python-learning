第一章 快速上手：基础知识

1.1 基础
	1. 整型数据类型没有长度限制
		a = 999999999999999999999999999999999999999999999999999999
	
	2. / : 除法运算的结果为小数，即浮点数（float或floating-point number）。
		1 / 2 = 0.5
		1 / 1 = 1.0
	
	3. // : 整除运算，可使用双斜杠
		1   // 2   = 0
		1   // 1   = 1
		5.0 // 2.4 = 2.0
		-10 // 3  = -4
		
	4. % : 求余（求模）运算符
		10   % 3    = 1
		2.75 % 0.5  = 0.25
		
	5. **: 乘方（求幂）运算符
		2 ** 3    = 8
		-3 ** 2   = -9
		(-3) ** 2 = 9
		
	6. 十六进制(0x)和二进制(0b)
		>>> 0xAF
		175
		>>> 0b1011010010
		722
		
	7. 获取用户输入
		x = input("x: ")
	
	8. 输出
		print(x)
		print('x = ' + input("x: "))
		print('x = ', input("x: "))
		
	9. 模块
	可将模块视为扩展，通过将其导入可以扩展Python功能。要导入模块，可使用特殊命令
		>>> import math
		>>> math.floor(32.9)
		32
		
		>>> import cmath
		>>> cmath.sqrt(-1)
		1j
		
	10. 强大的海龟绘图法
		from turtle import *
		forward(100)
		left(120)
		forward(100)
		left(120)
		forward(100)
		
	11. 从命令提示符运行 Python 脚本
	在Windows中使用如下命令来执行这个脚本：		
		C:\>python hello.py
	在UNIX系统中，可使用如下命令：
		$ python hello.py
		
	12. 让脚本像普通程序一样
		$ gedit hello.py
			#!/usr/bin/env python
			print('Hello,' + input('What is your name?'))
			input('Press <enter>')
			
		$ chmod a+x hello.py
		$./hello.py
		
1.2 input和print, pprint函数
	1. input函数输入字符串
		num = int(input('Enter a number: '))   # int(str) : 把字符串str转换为int
	
	2. print函数: 输出n个字符串(n >= 1)
	
	3.  import sys
		import pprint
		pprint.pprint(sys.paht)
			['',
			 '/opt/anaconda3/lib/python36.zip',
			 '/opt/anaconda3/lib/python3.6',
			 '/opt/anaconda3/lib/python3.6/lib-dynload',
			 '/opt/anaconda3/lib/python3.6/site-packages']
		
第二章 列表和元组

2.1 序列概述
	Python内置了多种序列，本章重点讨论其中最常用的两种： 列表和元组。另一种重要的序列是字符串，将在下一章更详细地讨论。
	列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于
	某种考虑需要禁止修改序列的情形。禁止修改序列通常出于技术方面的考虑，与Python的内部工作原理相关，这也是有些内置函数
	返回元组的原因所在。在你自己编写程序时，几乎在所有情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键，
	在这种情况下，不能使用列表来代替元组，因为字典键是不允许修改的。在需要处理一系列值时，序列很有用。在数据库中，可能使用
	序列来表示人，其中第一个元素为姓名，而第二个元素为年龄。如果使用列表来表示（所有元素都放在方括号内，并用逗号
	隔开），将类似于下面这样：
		>>> edward = ['Edward Gumby', 42]
		
	序列还可包含其他序列，因此可创建一个由数据库中所有人员组成的列表：
		>>> edward = ['Edward Gumby', 42]
		>>> john = ['John Smith', 50]
		>>> database = [edward, john]
		>>> database
		[['Edward Gumby', 42], ['John Smith', 50]]		
		
	注意: Python支持一种数据结构的基本概念，名为容器（container） 。容器基本上就是可包含其他对象的对象。
	两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。
	有一种既不是序列也不是映射的容器，它就是集合（set）

2.2 通用的序列操作

	有几种操作适用于所有序列，包括索引、 切片、 相加、 相乘和成员资格检查。另外， Python还提供了一些内置函数，
	可用于确定序列的长度以及找出序列中最大和最小的元素

2.2.1 索引
	序列中的所有元素都有编号——从0开始递增。

	正索引: 0           ~ (序列长度) -1
	负索引: -(序列长度)  ~  -1

	greeting = 'Hello'
	greeting[0] = 'H'
	greeting[4] = 'o'
	
    对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作
 	'Hello'[0]  = 'H'
  	'Hello'[-1] = 'o'

2.2.2 切片操作 (步长默认为1)
   第一个索引是包含的第一个元素的编号，但第二个索引是切片后余下的第一个元素的编号
  
   a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  (10个元素)
      
   1. 绝妙的简写	  
	   a[0] = a[-10] = 0
	   a[9] = a[-1]  = 9
	   a[0:10] :  取出全部元素(正数索引)
	   a[-10:] :  取出全部元素(负数索引)

	   如果切片始于序列开头，可省略第一个索引。
	   a[:3] = [0, 1, 2]

	   如果切片结束于序列末尾，可省略第二个索引。
	   a[-3:] = [7, 8, 9]

	   要复制整个序列，可将两个索引都省略。
	   a[:] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
   
	2. 更大的步长
		a) 取出偶数
			even = a[0:10:2]
			even = a[::2]

		b) 取出奇数
			odd = a[1:10:2]
			
	显式地指定步长时，也可使用前述简写。例如，要从序列中每隔3个元素提取1个，只需提供步长4即可。
		>>> numbers[::4]
		[1, 5, 9]
		
	当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素。 (在这种情况下，要正确地提取颇费思量。)
		>>> numbers[8:3:-1]
		[9, 8, 7, 6, 5]
		>>> numbers[10:0:-2]
		[10, 8, 6, 4, 2]
		>>> numbers[0:10:-2]
		[]
		>>> numbers[::-2]
		[10, 8, 6, 4, 2]		
		
		>>> numbers[5::-2]
		[6, 4, 2]
		>>> numbers[:5:-2]
		[10, 8]		

2.2.3 序列相加 	可使用加法运算符来拼接序列。
		>>> [1, 2, 3] + [4, 5, 6]
		[1, 2, 3, 4, 5, 6]

2.2.4 乘法 将序列与数x相乘时，将重复这个序列x次来创建一个新序列：
		>>>'python' * 5
		'pythonpythonpythonpythonpython'
		
		>>>[42] * 10
		[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]   
		
	在有些情况下，可能想使用表示“什么都没有”的值，如表示还没有在列表中添加任何内容。在这种情况下，
	可使用None。在Python中， None表示什么都没有。因此，要将列表的长度初始化为10，可像下面这样做：
		>>> sequence = [None] * 10
		>>> sequence
		[None, None, None, None, None, None, None, None, None, None]
		
2.2.5 成员资格 	

	a) 要检查特定的值是否包含在序列中，可使用运算符in。	
		>>> permissions = 'rw'
		>>> 'w' in permissions
		True
		>>> 'x' in permissions
		False
		>>> users = ['mlh', 'foo', 'bar']
		>>> input('Enter your user name: ') in users
		Enter your user name: mlh
		True
		>>> subject = '$$$ Get rich now!!! $$$'
		>>> '$$$' in subject
		True	
   
	b) 长度、最小值和最大值
		>>> numbers = [100, 34, 678]
		>>> len(numbers)
		3
		>>> max(numbers)
		678
		>>> min(numbers)
		34
		>>> max(2, 3)
		3
		>>> min(9, 3, 2, 5)
		2
   
2.3 列表： Python 的主力

2.3.1 函数 list
	>>> list('Hello')
	['H', 'e', 'l', 'l', 'o']
	
  (可将任何序列（而不仅仅是字符串）作为list的参数)	
	
2.3.2 基本的列表操作
	1. 修改列表：给元素赋值	
		>>> x = [1, 1, 1]
		>>> x[1] = 2
		>>> x
		[1, 2, 1]
	
	2. 删除元素
		>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
		>>> del names[2]
		>>> names
		['Alice', 'Beth', 'Dee-Dee', 'Earl']		
	
	3. 给切片赋值
	a. 切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。
		>>> name = list('Perl')
		>>> name
		['P', 'e', 'r', 'l']
		>>> name[2:] = list('ar')
		>>> name
		['P', 'e', 'a', 'r']
		
	b. 使用切片赋值还可在不替换原有元素的情况下插入新元素。
		>>> numbers = [1, 5]
		>>> numbers[1:1] = [2, 3, 4]   #“替换”了一个空切片，相当于插入了一个序列。
		>>> numbers
		[1, 2, 3, 4, 5]		
		
	c. 采取相反的措施来删除切片。
		>>> numbers
		[1, 2, 3, 4, 5]
		>>> numbers[1:4] = []   # 与del numbers[1:4]等效
		>>> numbers
		[1, 5]
		
2.3.3 列表方法
	1. append	方法append用于将一个对象附加到列表末尾。
		>>> numbers = [1, 2, 3]
		>>> numbers.append(4)
		>>> numbers
		[1, 2, 3, 4]
		
		>>> numbers = [1,2,3]
		>>> numbers.append([4,5])
		>>> numbers
		[1, 2, 3, [4, 5]]		
		
		请注意，与其他几个类似的方法一样， append也就地修改列表。这意味着它不会返回修改后的新列表，而是直接修改旧列表。
		
	2. clear 方法clear就地清空列表的内容。
		>>> lst = [1, 2, 3]
		>>> lst.clear()
		>>> lst
		[]
		这类似于切片赋值语句lst[:] = []		

	3. copy 方法 copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。
		>>> a = [1, 2, 3]
		>>> b = a
		>>> b[1] = 4
		>>> a
		[1, 4, 3]
 	要让a和b指向不同的列表，就必须将b关联到a的副本。

		>>> a = [1, 2, 3]
		>>> b = a.copy()   #这类似于b = a[:]或b = list(a)，它们也都复制a。	
		>>> b[1] = 4
		>>> a
		[1, 2, 3]
		
		
	4. count 方法count计算指定的元素在列表中出现了多少次。
		>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to')
		2
		>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
		>>> x.count(1)
		2
		>>> x.count([1, 2])
		1
	
	5. extend 方法extend让你能够同时将多个值附加到列表末尾
		>>> a = [1, 2, 3]
		>>> b = [4, 5, 6]
		>>> a.extend(b)
		>>> a
		[1, 2, 3, 4, 5, 6]
		
	注意extend函数与append函数的区别


	6. index 方法index在列表中查找指定值第一次出现的索引。
		>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
		>>> knights.index('who')
		4

	7. insert 	方法insert用于将一个对象插入列表。
		>>> numbers = [1, 2, 3, 5, 6, 7]
		>>> numbers.insert(3, 'four')
		>>> numbers
		[1, 2, 3, 'four', 5, 6, 7]
	
	8. pop 方法pop按索引从列表中删除一个元素（末尾为最后一个元素），并返回这一元素。
		>>> x = [1, 2, 3]
		>>> x.pop()  #无索引参数表示删除最后一个元素
		3
		>>> x
		[1, 2]
		>>> x.pop(0)
		1
		>>> x
		[2]
		
	注意: pop是唯一既修改列表又返回一个非None值的列表方法


	9. push和pop是大家普遍接受的两种栈操作（加入和取走）的名称。 Python没有提供push，但可
	使用append来替代。方法pop和append的效果相反，因此将刚弹出的值压入（或附加）后，得到的栈将与原来相同。
		>>> x = [1, 2, 3]
		>>> x.append(x.pop())
		>>> x
		[1, 2, 3]

	10. remove 	方法remove用于删除第一个为指定值的元素。
		>>> x = ['to', 'be', 'or', 'not', 'to', 'be']
		>>> x.remove('be')
		>>> x
		['to', 'or', 'not', 'to', 'be'	
		
	注意: pop方法按索引从列表中删除一个元素, 既修改列表又返回一个非None值
		 remove方法按指定值从列表中删除该元素, 它修改列表，但不返回任何值。
		 
	11. reverse 方法reverse按相反的顺序排列列表中的元素（我想你对此应该不会感到惊讶）。
		>>> x = [1, 2, 3]
		>>> x.reverse()
		>>> x
		[3, 2, 1]

	注意到reverse修改列表，但不返回任何值（与remove和sort等方法一样）。
	
	12. 函数reversed。这个函数不返回列表，而是返回一个迭代器（迭代器将在第9章详细介绍）。你可使用list将返回的对象转换为列表。
		>>> x = [1, 2, 3]
		>>> list(reversed(x))
		[3, 2, 1]
		 
	13. sort 方法sort用于对列表就地排序①。就地排序意味着对原来的列表进行修改，使其元素按顺序排列，
		而不是返回排序后的列表的副本。
		而不是返回排序后的列表的副本。
		而不是返回排序后的列表的副本。
		
		>>> x = [4, 6, 2, 1, 7, 9]					>>> x = [4, 6, 2, 1, 7, 9]
		>>> x.sort()								>>> y = x.copy()
		>>> x										>>> y.sort()
		[1, 2, 4, 6, 7, 9]							>>> x				
													[4, 6, 2, 1, 7, 9]
													>>> y
													[1, 2, 4, 6, 7, 9]	
	
	14. 非列表排序函数:sorted为获取排序后的列表的副本，另一种方式是使用函数sorted。
		>>> x = [4, 6, 2, 1, 7, 9]
		>>> y = sorted(x)
		>>> x
		[4, 6, 2, 1, 7, 9]
		>>> y
		[1, 2, 4, 6, 7, 9]
		
		按绝对值大小排序：
		>>> l = [36, 5, -12, 9, -21]
		>>> l1 = sorted(l, key=abs)
		>>> l1
		[5, 9, -12, -21, 36]
		>>> l
		[36, 5, -12, 9, -21]
		
		默认情况下，对字符串排序，是按照 ASCII 的大小比较的，由于'Z' < 'a'，结果，大写字母 Z 会排在小写字母 a 的前面。			
		>>> sorted(['bob', 'about', 'Zoo', 'Credit'])
		['Credit', 'Zoo', 'about', 'bob']

		忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。
		>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
		['about', 'bob', 'Credit', 'Zoo']
		
		要进行反向排序，不必改动 key 函数，可以传入第三个参数 reverse=True：
		>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
		['Zoo', 'Credit', 'bob', 'about']

	实际上，sorted函数用于可迭代的对象，但总是返回一个列表②。
	
	15. 高级排序 方法sort接受两个可选参数： key和reverse。这两个参数通常是按名称指定的，称为关键字参数
	参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比
	另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，
	可将参数key设置为函数len。
	
		>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate']
		>>> x.sort(key=len)
		>>> x
		['add', 'acme', 'aerate', 'abalone', 'aardvark']
			
		对于另一个关键字参数reverse，只需将其指定为一个真值（True或False），以指出是否要按相反的顺序对列表进行排序。			
		>>> x = [4, 6, 2, 1, 7, 9]
		>>> x.sort(reverse=True)
		>>> x
		[9, 7, 6, 4, 2, 1]
		
	函数sorted也接受参数key和reverse。


2.4 元组：不可修改的序列
	与列表一样，元组也是序列，唯一的差别在于元组是不能修改的（你可能注意到了，字符串也不能修改）。元组语法很简单，
	只要将一些值用逗号分隔，就能自动创建一个元组。
		>>> 1, 2, 3
		(1, 2, 3)

	元组还可用圆括号括起（这也是通常采用的做法）。
		>>> (1, 2, 3)
		(1, 2, 3)

	空元组用两个不包含任何内容的圆括号表示。
		>>> ()
		()
		
	如何表示只包含一个值的元组呢？这有点特殊：虽然只有一个值，也必须在它后面加上逗号。
		>>> 42
		42
		>>> 42,
		(42,)	
		>>> (42,)
		(42,)
		
	最后两个示例创建的元组长度为1，而第一个示例根本没有创建元组。逗号至关重要，仅将
	值用圆括号括起不管用： (42)与42完全等效。但仅仅加上一个逗号，就能完全改变表达式的值。
		>>> 3 * (40 + 2)
		126
		>>> 3 * (40 + 2,)
		(42, 42, 42)
	
	函数tuple的工作原理与list很像：它将一个序列作为参数，并将其转换为元组①。如果参数已经是元组，就原封不动地返回它。
		>>> tuple([1, 2, 3])
		(1, 2, 3)
		>>> tuple('abc')
		('a', 'b', 'c')
		>>> tuple((1, 2, 3))
		(1, 2, 3)

	你可能意识到了，元组并不太复杂，而且除创建和访问其元素外，可对元组执行的操作不多。
	元组的创建及其元素的访问方式与其他序列相同。
		>>> x = (1, 2, 3)  # x = 1, 2, 3
		>>> x[1]
		2
		>>> x[0:2]
		(1, 2)	

	元组的切片也是元组，就像列表的切片也是列表一样。为何要熟悉元组呢？原因有以下两个。
	1)它们用作映射中的键（以及集合的成员），而列表不行。映射将在第4章详细介绍。
	2)有些内置函数和方法返回元组，这意味着必须跟它们打交道。只要不尝试修改元组，与
	元组“打交道”通常意味着像处理列表一样处理它们（需要使用元组没有的index和count等方法时例外）。
	
	一般而言，使用列表足以满足对序列的需求。
	
	2.5.1 本章介绍的新函数
	
	---------------------------------
	函 数				 	描 述
	---------------------------------
	len(seq) 			返回序列的长度
	list(seq) 			将序列转换为列表
	max(args) 			返回序列或一组参数中的最大值
	min(args) 			返回序列和一组参数中的最小值
	reversed(seq) 		能够反向迭代序列
	sorted(seq) 		返回一个有序列表，其中包含指定序列中的所有元素
	tuple(seq) 			将序列转换为元组

第3章 使用字符串

3.1 字符串基本操作
	
	所有标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串，
	但别忘了字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的。

3.2 设置字符串的格式：精简版
	
	将值转换为字符串并设置其格式是一个重要的操作，
	1) 主要的解决方案是使用字符串格式设	置运算符——百分号。这个运算符的行为类似于C语言中的经典函数printf：在%左边指定一个字
	符串（格式字符串），并在右边指定要设置其格式的值。
	2) 指定要设置其格式的值时，可使用单个值（如字符串或数字）,可使用元组（如果要设置多个值的格式），还可使用字典，其中最常见的是元组。
		>>>format = "Hello, %s. %s enough for you?" 
		>>>values = ('world', 'Hot')
		>>>format % values
		'Hello, world. Hot enough for you?'
		
	上述格式字符串中的%s称为转换说明符，指出了要将值插入什么地方。 

	3) 编写新代码时，应选择使用字符串方法format，它融合并强化了早期方法的优点。使用这种方法时，
	每个替换字段都用花括号括起，其中可能包含名称，还可能包含有关如何对相应的值进行转换和格式设置的信息。
	在最简单的情况下，替换字段没有名称或将索引用作名称。
		>>> "{}, {} and {}".format("first", "second", "third")
		'first, second and third'
		>>> "{0}, {1} and {2}".format("first", "second", "third")
		'first, second and third'		
				
	然而，索引无需像上面这样按顺序排列。
		>>> "{3} {0} {2} {1} {3} {0}".format("be", "not", "or", "to")
		'to be or not to be'
		
	命名字段的工作原理与你预期的完全相同。
		>>> from math import pi
		>>> "{name} is approximately {value:.2f}.".format(value=pi, name="π")
		'π is approximately 3.14.'

	当然，关键字参数的排列顺序无关紧要。在这里，我还指定了格式说明符.2f，并使用冒号将其与字段名隔开。
	它意味着要使用包含2位小数的浮点数格式。如果没有指定.2f，结果将如下：
		>>> "{name} is approximately {value}.".format(value=pi, name="π")
		'π is approximately 3.141592653589793.'
		
	最后，在Python 3.6中，如果变量与替换字段同名，还可使用一种简写。在这种情况下，可
	使用f字符串——在字符串前面加上f。
		>>> from math import e
		>>> f"Euler's constant is roughly {e}."
		"Euler's constant is roughly 2.718281828459045."
		
	在这里，创建最终的字符串时，将把替换字段e替换为变量e的值。这与下面这个更明确一些的表达式等价
		>>> "Euler's constant is roughly {e}.".format(e=e)
		"Euler's constant is roughly 2.718281828459045."
		
	c = a + b :
	
		>>> a = input('input value of a:')  #  a = '1'
		>>> b = input('input value of b:')  #  b = '2'
		>>> c = int(a) + int(b)
		>>> "{} + {} = {}".format(a, b, c)   
		'1 + 2 = 3'
		
		>>>"{0} + {1} = {2}".format(a, b, c)
		'1 + 2 = 3'
		
		>>>"{a} + {b} = {c}".format(a=a, b=b, c=c)
		'1 + 2 = 3'			

3.3 设置字符串的格式：完整版

3.3.1 替换字段名
	在最简单的情况下，只需向format提供要设置其格式的未命名参数，并在格式字符串中使用未命名字段。此时，将按顺序将字段和参数配对。
	你还可给参数指定名称，这种参数将被用于相应的替换字段中。你可混合使用这两种方法。

	>>> "{foo} {} {bar} {}".format(1, 2, bar=4, foo=3)
	'3 1 4 2'
	
	>>> "{foo} {1} {bar} {0}".format(1, 2, bar=4, foo=3)
	'3 2 4 1

3.3.2 基本转换

	指定要在字段中包含的值后，就可添加有关如何设置其格式的指令了。首先，可以提供一个转换标志。
		>>> print("{pi!s} {pi!r} {pi!a}".format(pi="π"))
		π 'π' '\u03c0


	上述三个标志（s、 r和a）指定分别使用str、 repr和ascii进行转换。函数str通常创建外观普通的字符串版本（这里没有对输入字符串做任何处理）。
	函数repr尝试创建给定值的Python表示（这里是一个字符串字面量）。
	
	表3-1 字符串格式设置中的类型说明符
	  类型 含 义
		b 将整数表示为二进制数
		c 将整数解读为Unicode码点
		d 将整数视为十进制数进行处理，这是整数默认使用的说明符
		e 使用科学表示法来表示小数（用e来表示指数）
		E 与e相同，但使用E来表示指数
		f 将小数表示为定点数
		F 与f相同，但对于特殊值（nan和inf），使用大写表示
		g 自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数
		G 与g相同，但使用大写来表示指数和特殊值
		n 与g相同，但插入随区域而异的数字分隔符
		o 将整数表示为八进制数
		s 保持字符串的格式不变，这是默认用于字符串的说明符
		x 将整数表示为十六进制数并使用小写字母
		X 与x相同，但使用大写字母
		% 将数表示为百分比值（乘以100，按说明符f设置格式，再在后面加上%）


3.3.3 宽度、精度和千位分隔符

宽度是使用整数指定的，如下所示：
>>> "{num:10}".format(num=3)
' 3'
>>> "{name:10}".format(name="Bob")
'Bob

精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点。
>>> "Pi day is {pi:.2f}".format(pi=pi)
'Pi day is 3.14'

可同时指定宽度和精度。
>>> "{pi:10.2f}".format(pi=pi)
' 3.14'
实际上，对于其他类型也可指定精度，但是这样做的情形不太常见。
>>> "{:.5}".format("Guido van Rossum")
'Guido'
最后，可使用逗号来指出你要添加千位分隔符。
>>> 'One googol is {:,}'.format(10**100)
'One googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,00
0,000,000,000,000,000,000,000,000,000,000,000,000,000,000

3.3.4 符号、对齐和用 0 填充

在指定宽
度和精度的数前面，可添加一个标志。这个标志可以是零、加号、减号或空格，其中零表示使用
0来填充数字。
>>> '{:010.2f}'.format(pi)
'0000003.14'
要指定左对齐、右对齐和居中，可分别使用<、 >和^。
>>> print('{0:<10.2f}\n{0:^10.2f}\n{0:>10.2f}'.format(pi))
3.14
3.14
3.14
可以使用填充字符来扩充对齐说明符，这样将使用指定的字符而不是默认的空格来填充。
>>> "{:$^15}".format(" WIN BIG ")
'$$$ WIN BIG $$$'
还有更具体的说明符=，它指定将填充字符放在符号和数字之间。
>>> print('{0:10.2f}\n{1:10.2f}'.format(pi, -pi))
3.14
-3.14
>>> print('{0:10.2f}\n{1:=10.2f}'.format(pi, -pi))
3.14
- 3.14
如果要给正数加上符号，可使用说明符+（将其放在对齐说明符后面） ，而不是默认的-。如
果将符号说明符指定为空格，会在正数前面加上空格而不是+。
>>> print('{0:-.2}\n{1:-.2}'.format(pi, -pi)) #默认设置
3.1
-3.1
>>> print('{0:+.2}\n{1:+.2}'.format(pi, -pi))
+3.1
-3.1
>>> print('{0: .2}\n{1: .2}'.format(pi, -pi))
3.1
-3.1
需要介绍的最后一个要素是井号（#）选项，你可将其放在符号说明符和宽度之间（如果指
定了这两种设置）。这个选项将触发另一种转换方式，转换细节随类型而异。例如，对于二进制、
八进制和十六进制转换，将加上一个前缀。

>>> "{:b}".format(42)
'101010'
>>> "{:#b}".format(42)
'0b101010'
对于各种十进制数，它要求必须包含小数点（对于类型g，它保留小数点后面的零）。
>>> "{:g}".format(42)
'42'
>>> "{:#g}".format(42)
'42.0000

3.4 字符串方法

3.4.1 center
方法center通过在两边添加填充字符（默认为空格）让字符串居中。
>>> "The Middle by Jimmy Eat World".center(39)
' The Middle by Jimmy Eat World '
>>> "The Middle by Jimmy Eat World".center(39, "*")
'*****The Middle by Jimmy Eat World*****'
附录B： ljust、 rjust和zfill。
3.4.2 find
方法find在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。
>>> 'With a moo-moo here, and a moo-moo there'.find('moo')
7
>>> title = "Monty Python's Flying Circus"
>>> title.find('Monty')
0
>>> title.find('Python')
6
>>> title.find('Flying')
15
>>> title.find('Zirquss')
-1

还可指定搜索的起点和终点（它们都是可选的）。
>>> subject = '$$$ Get rich now!!! $$$'
>>> subject.find('$$$')
0
>>> subject.find('$$$', 1) # 只指定了起点
20
>>> subject.find('!!!')
16
>>> subject.find('!!!', 0, 16) # 同时指定了起点和终点
-1

3.4.3 join
join是一个非常重要的字符串方法，其作用与split相反，用于合并序列的元素。
>>> seq = [1, 2, 3, 4, 5]
>>> sep = '+'
>>> sep.join(seq) # 尝试合并一个数字列表
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: sequence item 0: expected string, int found
>>> seq = ['1', '2', '3', '4', '5']
>>> sep.join(seq) # 合并一个字符串列表
'1+2+3+4+5'
>>> dirs = '', 'usr', 'bin', 'env'
>>> '/'.join(dirs)
'/usr/bin/env'
>>> print('C:' + '\\'.join(dirs))
C:\usr\bin\env

3.4.4 lower
方法lower返回字符串的小写版本。
>>> 'Trondheim Hammer Dance'.lower()
'trondheim hammer dance

3.4.5 replace
方法replace将指定子串都替换为另一个字符串，并返回替换后的结果。
>>> 'This is a test'.replace('is', 'eez')
'Theez eez a test'

3.4.6 split
split是一个非常重要的字符串方法，其作用与join相反，用于将字符串拆分为序列。
>>> '1+2+3+4+5'.split('+')
['1', '2', '3', '4', '5']
>>> '/usr/bin/env'.split('/')
['', 'usr', 'bin', 'env']
>>> 'Using the default'.split()
['Using', 'the', 'default']

3.4.7 strip
方法strip将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果。
>>> ' internal whitespace is kept '.strip()
'internal whitespace is kept'

3.4.8 translate
方法translate与replace一样替换字符串的特定部分，但不同的是它只能进行单字符替换。
这个方法的优势在于能够同时替换多个字符，因此效率比replace高。

3.4.9 判断字符串是否满足特定的条件
很多字符串方法都以is打头，如isspace、 isdigit和isupper，它们判断字符串是否具有特定
的性质（如包含的字符全为空白、数字或大写）。如果字符串具备特定的性质，这些方法就返回
True，否则返回False。
附录B： isalnum、 isalpha、 isdecimal、 isdigit、 isidentifier、 islower、 isnumeric、
isprintable、 isspace、 istitle、 isupper。


第4章 字典: 当索引行不通时

字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。键可能是数、字符串或元组。

4.1 字典的用途

	在很多情况下，使用字典都比使用列表更合适。下面是Python字典的一些用途：
	 表示棋盘的状态，其中每个键都是由坐标组成的元组；
	 存储文件修改时间，其中的键为文件名；
	 数字电话/地址簿。

4.2 创建和使用字典

	字典由键及其相应的值组成，这种键-值对(用:分隔)称为项（item）。

	phonebook = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}
	
4.2.1 函数 dict
可使用函数dict①从其他映射（如其他字典）或键值对序列创建字典。
>>> items = [('name', 'Gumby'), ('age', 42)]
>>> d = dict(items)
>>> d
{'age': 42, 'name': 'Gumby'}
>>> d['name']
'Gumby'
还可使用关键字实参来调用这个函数，如下所示：
>>> d = dict(name='Gumby', age=42)
>>> d
{'age': 42, 'name': 'Gumby'}

4.2.2 基本的字典操作
字典的基本行为在很多方面都类似于序列。
 len(d)返回字典d包含的项（键值对）数。
 d[k]返回与键k相关联的值。
 d[k] = v将值v关联到键k。
 del d[k]删除键为k的项。
 kind 检查字典d是否包含键为k的项。

虽然字典和列表有多个相同之处，但也有一些重要的不同之处。
 键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变的类型，如浮点数（实数）、字符串或元组。
 自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。然而，如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。
 成员资格：表达式k in d（其中d是一个字典）查找的是键而不是值，而表达式v in l（其中l是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。

4.2.3 将字符串格式设置功能用于字典

使用format_map来指出你将通过一个映射来提供所需的信息。
	>>>phonebook = {'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'}
	>>>"Cecil's phone number is {Cecil}.".format_map(phonebook)
	"Cecil's phone number is 3258.

4.2.4 字典方法

1. clear
	方法clear删除所有的字典项，这种操作是就地执行的（就像list.sort一样），因此什么都不返回（或者说返回None）。
	我们来看两个场景。下面是第一个场景：
	>>> x = {}
	>>> y = x
	>>> x['key'] = 'value'
	>>> y
	{'key': 'value'}
	>>> x = {}
	>>> x = {}
	{'key': 'value'}
	下面是第二个场景：
	>>> x = {}
	>>> y = x
	>>> x['key'] = 'value'
	>>> y
	{'key': 'value'}
	>>> x.clear()
	>>> y
	{}

2. copy
	方法copy返回一个新字典，其包含的键值对与原来的字典相同（这个方法执行的是浅复制，因为值本身是原件，而非副本）。

	>>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']}
	>>> y = x.copy()
	>>> y['username'] = 'mlh'
	>>> y['machines'].remove('bar')
	>>> y
	{'username': 'mlh', 'machines': ['foo', 'baz']}
	>>> x
	{'username': 'admin', 'machines': ['foo', 'baz']}

	如你所见，当替换副本中的值时，原件不受影响。然而，如果修改副本中的值（就地修改而
	不是替换） ，原件也将发生变化，因为原件指向的也是被修改的值（如这个示例中的'machines'
	列表所示）。
	为避免这种问题，一种办法是执行深复制，即同时复制值及其包含的所有值，等等。为此，
	可使用模块copy中的函数deepcopy。
	>>> from copy import deepcopy
	>>> d = {}
	>>> d['names'] = ['Alfred', 'Bertrand']
	>>> c = d.copy()
	>>> dc = deepcopy(d)
	>>> d['names'].append('Clive')
	>>> c
	{'names': ['Alfred', 'Bertrand', 'Clive']}
	>>> dc
{'names': ['Alfred', 'Bertrand']}

3. fromkeys
	方法fromkeys创建一个新字典，其中包含指定的键，且每个键对应的值都是None。
	>>> dict.fromkeys(['name', 'age'])
	{'age': None, 'name': None}
	如果你不想使用默认值None，可提供特定的值。
	>>> dict.fromkeys(['name', 'age'], '(unknown)')
	{'age': '(unknown)', 'name': '(unknown)'}

4. get
	方法get为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。
	>>> d = {}
	>>> print(d['name'])
	Traceback (most recent call last):
	File "<stdin>", line 1, in ?
	KeyError: 'name'
	而使用get不会这样：
	>>> print(d.get('name'))
	None
	如你所见，使用get来访问不存在的键时，没有引发异常，而是返回None。你可指定“默认”值，这样将返回你指定的值而不是None。
	>>> d.get('name', 'N/A')
	'N/A'
	如果字典包含指定的键， get的作用将与普通字典查找相同。
	>>> d['name'] = 'Eric'
	>>> d.get('name')
	'Eric

5. items
	方法items返回一个包含所有字典项的列表，其中每个元素都为(key, value)的形式。字典项
	在列表中的排列顺序不确定。
	>>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0}
	>>> d.items()
	dict_items([('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')])
	返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代（迭代将在第5章详细介绍）。
	另外，你还可确定其长度以及对其执行成员资格检查。
	>>> it = d.items()
	>>> len(it)
	3
	>>> ('spam', 0) in it
	True
	视图的一个优点是不复制，它们始终是底层字典的反映，即便你修改了底层字典亦如此。
	>>> d['spam'] = 1
	>>> ('spam', 0) in it
	False
	>>> d['spam'] = 0
	>>> ('spam', 0) in it
	True
	然而，如果你要将字典项复制到列表中（在较旧的Python版本中，方法items就是这样做的），
	可自己动手做。
	>>> list(d.items())
	[('spam', 0), ('title', 'Python Web Site'), ('url', 'http://www.python.org')]

6. keys
	方法keys返回一个字典视图，其中包含指定字典中的键。
	
7. values
	方法values返回一个由字典中的值组成的字典视图。不同于方法keys，方法values返回的视图可能包含重复的值。
		>>> d = {}
		>>> d[1] = 1
		>>> d[2] = 2
		>>> d[3] = 3
		>>> d[4] = 1
		>>> d.values()
		dict_values([1, 2, 3, 1])	
		
8. pop
	方法pop可用于获取与指定键相关联的值，并将该键值对从字典中删除。
	>>> d = {'x': 1, 'y': 2}
	>>> d.pop('x')
	1
	>>> d
	{'y': 2}
	
9. popitem
	方法popitem类似于list.pop，但list.pop弹出列表中的最后一个元素，而popitem随机地出一个字典项，因为字典项的顺序是不确定的，
	没有“最后一个元素”的概念。如果你要以高效地方式逐个删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。
	>>> d = {'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'}
	>>> d.popitem()
	('url', 'http://www.python.org')
	>>> d
	{'spam': 0, 'title': 'Python Web Site'}
	虽然popitem类似于列表方法pop，但字典没有与append（它在列表末尾添加一个元素）对应的方法。这是因为字典是无序的，类似的方法毫无意义。

10. setdefault
	方法setdefault有点像get，因为它也获取与指定键相关联的值，但除此之外， setdefault还在字典不包含指定的键时，在字典中添加指定的键值对。
	>>> d = {}
	>>> d.setdefault('name', 'N/A')
	'N/A'
	>>> d
	{'name': 'N/A'}
	>>> d['name'] = 'Gumby'
	>>> d.setdefault('name', 'N/A')
	'Gumby'
	>>> d
	{'name': 'Gumby'}
	如你所见，指定的键不存在时， setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与get一样，值是可选的；如果没有指定，默认为None。
	>>> d = {}
	>>> print(d.setdefault('name'))
	None
	>>> d
	{'name': None}
	
11. update
	方法update使用一个字典中的项来更新另一个字典。
	>>> d = {
	... 'title': 'Python Web Site',
	... 'url': 'http://www.python.org',
	... 'changed': 'Mar 14 22:09:15 MET 2016'
	... }	
	>>> x = {'title': 'Python Language Website'}
	>>> d.update(x)
	>>> d
	{'url': 'http://www.python.org', 'changed':
	'Mar 14 22:09:15 MET 2016', 'title': 'Python Language Website'}
	对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。
	可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键值对组成的序列（或其他可迭代对象）或关键字参数。

	friends = {'lxx': {'phone': 18888888888, 'addr': 'beijing'}, 'zwj': {'phone': 18010622207, 'addr': 'chengdu'}, 'hjj': {'phone': 18981808976, 'addr': 'chengdu'}}
	zwj_phone = friends['zwj']['phone']

第5章 条件、循环及其他语句

5.1 再谈 print 和 import

5.1.1 打印多个参数
		>>> print('Age:', 42)
		Age: 42
	
		>>> name = 'Gumby'
		>>> salutation = 'Mr.'
		>>> greeting = 'Hello,'
		>>> print(greeting, salutation, name)
		Hello, Mr. Gumby
		
5.1.2 导入时重命名
		>>> import math as foobar
		>>> foobar.sqrt(4)
		2.0
	下面是一个导入特定函数并给它指定别名的例子：
		>>> from math import sqrt as foobar
		>>> foobar(4)
		2.0	
		
5.2 赋值魔法		
		
5.2.1 序列解包	

	>>> x, y, z = 1, 2, 3
	>>> print(x, y, z)
	1 2 3		
		
	这在使用返回元组（或其他序列或可迭代对象）的函数或方法时很有用。假设要从字典中随便获取（或删除）一个键值对，
	可使用方法popitem，它随便获取一个键值对并以元组的方式返回。接下来，可直接将返回的元组解包到两个变量中。
	>>> scoundrel = {'name': 'Robin', 'girlfriend': 'Marion'}
	>>> key, value = scoundrel.popitem()
	>>> key
	'girlfriend'
	>>> value
	'Marion'		

	这让函数能够返回被打包成元组的多个值，然后通过一条赋值语句轻松地访问这些值。
	要解包的序列包含的元素个数必须与你在等号左边列出的目标个数相同，否则Python将引发异常。
	
	
	可使用星号运算符（*）来收集多余的值，这样无需确保值和变量的个数相同，如下例所示：
		>>> a, b, *rest = [1, 2, 3, 4]
		>>> rest
		[3, 4]
		
	还可将带星号的变量放在其他位置。
		>>> name = "Albus Percival Wulfric Brian Dumbledore"
		>>> first, *middle, last = name.split()
		>>> middle
		['Percival', 'Wulfric', 'Brian']		
		
	赋值语句的右边可以是任何类型的序列，但带星号的变量最终包含的总是一个列表。在变量和值的个数相同时亦如此。
	>>> a, *b, c = "abc"
	>>> a, b, c
	('a', ['b'], 'c')
	这种收集方式也可用于函数参数列表中		
	
5.2.2 链式赋值
	链式赋值是一种快捷方式，用于将多个变量关联到同一个值。这有点像前一节介绍的并行赋值，但只涉及一个值：
		x = y = somefunction()
	上述代码与下面的代码等价：
		y = somefunction()
		x = y
		
5.2.3 增强赋值
	可以不编写代码x = x + 1，而将右边表达式中的运算符（这里是+）移到赋值运算符（=）的前面，从而写成x += 1。这称为增强赋值，适用于所有标准运算符，如*、 /、 %等。
		>>> x = 2
		>>> x += 1
		>>> x *= 2
		>>> x
		6

	增强赋值也可用于其他数据类型（只要使用的双目运算符可用于这些数据类型）。
		>>> fnord = 'foo'
		>>> fnord += 'bar'
		>>> fnord *= 2
		>>> fnord
		'foobarfoobar'
	通过使用增强赋值，可让代码更紧凑、更简洁，同时在很多情况下的可读性更强。
	
5.3 代码块：缩进的乐趣	

5.4 条件和条件语句
	name = input('What is your name?')
	if name.endswith('Gumby'):
		print('Hello, Mr. Gumby')
	else:
		print('Hello, stranger')
				
	num = int(iut("Please enter a number:"))
	f num > 0:
		print("{} is positive".format(num))
	elif num == 0:
		print("{} is 0".format(num))
	else:
		print("{} is negtive",foramt(num))
		
5.4.5 代码块嵌套
	下面穿插点额外的内容。你可将if语句放在其他if语句块中，如下所示：
		name = input('What is your name? ')
		if name.endswith('Gumby'):
			if name.startswith('Mr.'):
				print('Hello, Mr. Gumby')
			elif name.startswith('Mrs.'):
				print('Hello, Mrs. Gumby')
			else:
				print('Hello, Gumby')
		else:
			print('Hello, stranger')		
		
5.4.6 更复杂的条件

1. 比较运算符
	在条件表达式中，最基本的运算符可能是比较运算符，它们用于执行比较。表5-1对比较运算符做了总结。
				表5-1 Python比较运算符
	--------------------------------------------------------------------
	表达式  			描 述
	--------------------------------------------------------------------
	x == y 			x 等于y
	x < y 			x小于y
	x > y 			x大于y
	x >= y 			x大于或等于y
	x <= y 			x小于或等于y
	x != y 			x不等于y
	x is y 			x和y是同一个对象
	x is not y 		x和y是不同的对象
	x in y 			x是容器（如序列） y的成员
	x not in 		y x不是容器（如序列） y的成员	
	
	注意: ==用来检查两个对象是否相等，而is用来检查两个对象是否相同（是同一个对象）。
	
	在Python 3中，已经不允许这样比较不兼容的类型了。
	
	与赋值一样， Python也支持链式比较：可同时使用多个比较运算符，如0 < age < 100。	
	
	有些比较运算符需要特别注意，下面就来详细介绍。
	
	1) 相等运算符
		要确定两个对象是否相等，可使用比较运算符，用两个等号（==）表示。
		>>> "foo" == "foo"
		True
		>>> "foo" == "bar"
		False
		两个等号？为何不像数学中那样使用一个等号呢？相信你很聪明，自己就能够明白其中的原因，但这里还是试试一个等号吧。
		>>> "foo" = "foo"
		SyntaxError: can't assign to literal	
		
		一个等号是赋值运算符，用于修改值，而进行比较时你可不想这样做。
		
	2)is：相同运算符 这个运算符很有趣，其作用看似与==一样，但实际上并非如此。
		>>> x = y = [1, 2, 3]
		>>> z = [1, 2, 3]
		>>> x == y
		True
		>>> x == z
		True
		>>> x is y
		True
		>>> x is z
		False		
	
	因为is检查两个对象是否相同（而不是相等） 。变量x和y指向同一个列表，而z指向另一个列表
	（其中包含的值以及这些值的排列顺序都与前一个列表相同） 。这两个列表虽然相等，但并非同一个对象。
	
	3)in：成员资格运算符
		运算符in在2.2.5节介绍过，与其他比较运算符一样，它也可用于条件表达式中。
		
		name = input('What is your name?')
		if 's' in name:
			print('Your name contains the letter "s".')
		else:
			print('Your name does not contain the letter "s".')
		
	4)字符串和序列的比较
		字符串是根据字符的字母排列顺序进行比较的。
			>>> "alpha" < "beta"
			True

		虽然基于的是字母排列顺序，但字母都是Unicode字符，它们是按码点排列的。	
		
2. 布尔运算符

	number = int(input('Enter a number between 1 and 10: '))
	if 1 <= number <= 10:
		print('Great!')
	else:
		print('Wrong!')
	
5.4.7 断言
	
如果知道必须满足特定条件，程序才能正确地运行，可在程序中添加assert语句充当检查点，这很有帮助。还可在条件后面添加一个字符串，对断言做出说明。
	>>> age = -1
	>>> assert 0 < age < 100, 'The age must be realistic'
	Traceback (most recent call last):
	File "<stdin>", line 1, in ?
	AssertionError: The age must be realistic	
	
5.5 循环	
	
5.5.1 while 循环
	为避免前述示例所示的繁琐代码，能够像下面这样做很有帮助：
		x = 1
		while x <= 100:
		print(x)
		x += 1	
		
		
5.5.2 for 循环
	基本上， 可迭代对象是可使用for循环进行遍历的对象。第9章将详细介绍可迭代对象和迭代器。就目前而言，只需将可迭代对象视为序列即可

	words = ['this', 'is', 'an', 'ex', 'parrot']
	for word in words:
	print(word)
或
	numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	for number in numbers:
	print(number)
	
	鉴于迭代（也就是遍历）特定范围内的数是一种常见的任务， Python提供了一个创建范围的内置函数。
	
	>>> range(0, 10)
	range(0, 10)
	>>> list(range(0, 10))
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	
	范围类似于切片。它们包含起始位置（这里为0），但不包含结束位置（这里为10） 。在很多情况下，你都希望范围的起始位置为0。
	实际上，如果只提供了一个位置，将把这个位置视为结束位置，并假定起始位置为0。
		>>> range(10)
		range(0, 10)
		
	下面的程序打印数1～100：
		for number in range(1,101):
			print(number)
			
		sum = 0
		hundreds = list(range(1, 101))
		for i in range(0, len(hundreds)):
			sum = sum + hundreds[i]

		print(sum)
			
5.5.3 迭代字典
	
    要遍历字典的所有关键字，可像遍历序列那样使用普通的for语句。
    d = {'x': 1, 'y': 2, 'z': 3}
    for key in d:
        print(key, 'corresponds to', d[key])

    也可使用keys等字典方法来获取所有的键。如果只对值感兴趣，可使用d.values。你可能还
    记得， d.items以元组的方式返回键值对。 for循环的优点之一是，可在其中使用序列解包。
    for key, value in d.items():
        print(key, 'corresponds to', value)

    注意: 字典元素的排列顺序是不确定的。换而言之，迭代字典的键或值时，一定会处理所有的
    键或值，但不知道处理的顺序。如果顺序很重要，可将键或值存储在一个列表中并对列
    表排序，再进行迭代。要让映射记住其项的插入顺序，可使用模块collections中的
    OrderedDict类。

5.5.4 一些迭代工具
    
    1. 并行迭代
    有时候，你可能想同时迭代两个序列。假设有下面两个列表：
    names = ['zwj', 'xxx', 'jjj', 'zjh']
    ages = [22, 25, 32, 10]
    如果要打印名字和对应的年龄，可以像下面这样做：
    for i in range(len(names)):
        print(names[i], 'is', ages[i], 'years old')

    >>> list(zip(names,ages))
    [('zwj', 22), ('xxx', 25), ('jjj', 32), ('zjh', 10)]

    “缝合”后，可在循环中将元组解包。
    for name, age in zip(names, ages):
        print('{} is {} years old'.format(name, age))

    zwj is 22 years old
    xxx is 25 years old
    jjj is 32 years old
    zjh is 10 years old


    for name, age in zip(names, ages):
        print("'{}' is {} years old".format(name, age))

    'zwj' is 22 years old
    'xxx' is 25 years old
    'jjj' is 32 years old
    'zjh' is 10 years old


    函数zip可用于“缝合”任意数量的序列。需要指出的是，当序列的长度不同时，函数zip将
    在最短的序列用完后停止“缝合”。

    >>> list(zip(range(5), range(100000000)))
    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

    2. 迭代时获取索引
    在有些情况下，你需要在迭代对象序列的同时获取当前对象的索引。
    使用内置函数enumerate。这个函数让你能够迭代索引值对，其中的索引是自动提供的。
    names = ['zwj', 'xxx', 'hjj', 'zjh']

    >>> names
    ['zwj', 'xxx', 'hjj', 'zjh']
    >>> list(enumerate(names))
    [(0, 'zwj'), (1, 'xxx'), (2, 'hjj'), (3, 'zjh')]

    for index, name in enumerate(names):
        print("The {}th name is {}".format(index, name))

    3. 反向迭代和排序后再迭代
    来看另外两个很有用的函数： reversed和sorted。它们类似于列表方法reverse和sort （sorted
    接受的参数也与sort类似），但可用于任何序列或可迭代的对象，且不就地修改对象，而是返回
    反转和排序后的版本。

    >>> ages
    [22, 25, 32, 10]
    >>> age = sorted(ages)
    >>> age
    [10, 22, 25, 32]
    >>> ages
    [22, 25, 32, 10]


    >>> list(reversed(names))
    ['zjh', 'jjj', 'xxx', 'zwj']

    >>> '.'.join(names)
    'zwj.xxx.jjj.zjh'
    >>> '.'.join(reversed(names))
    'zjh.jjj.xxx.zwj'


    请注意， sorted返回一个列表，而reversed像zip那样返回一个更神秘的可迭代对象。你无需
    关心这到底意味着什么，只管在for循环或join等方法中使用它，不会有任何问题。只是你不能
    对它执行索引或切片操作，也不能直接对它调用列表的方法。要执行这些操作，可先使用list对
    返回的对象进行转换
	
5.5.5 跳出循环

1. break

from math import sqrt
for n in range(99, 0, -1):
	root = sqrt(n)
	if root == int(root):
		print(n)
		break
		
2. continue
	
for n in range(101):
	if n % 2 != 0: continue
	print(n)
		
3. while TRUE / break

while True:
    n = input('Please enter a even number:')
    if int(n) % 2 != 0 : break

5.5.6 循环中的 else 子句
while True:
    inputStr = input('Please enter a integer number:')
    inputNum = int(inputStr)
    
    if inputNum > 0 :
        print("{} > 0".format(inputNum))
    elif inputNum == 0 :
        print("{} == 0".format(inputNum))
    else:
        print("{} < 0".format(inputNum))
		
5.6 简单推导

	列表推导是一种从其他列表创建列表的方式，类似于数学中的集合推导。列表推导的工作原理非常简单，有点类似于for循环。

r = range(10)
s = [x * x for x in r]
print(s)

[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]	

s = [x * x for x in r if x > 0]
print(s)
[1, 4, 9, 16, 25, 36, 49, 64, 81]

	还可添加更多的for部分。
	
>>> [(x, y) for x in range(3) for y in range(3)]
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]

	作为对比，下面的两个for循环创建同样的列表：
	
result = []
for x in range(3):
for y in range(3)
result.append((x, y))

	与以前一样，使用多个for部分时，也可添加if子句。
>>> girls = ['alice', 'bernice', 'clarice']
>>> boys = ['chris', 'arnold', 'bob']
>>> [b+'+'+g for b in boys for g in girls if b[0] == g[0]]
['chris+clarice', 'arnold+alice', 'bob+bernice']

生成excel的sheet表格的表头(ord函数: 字符--> ASCII码值, ord函数: ASCII码值 ---> 字符)
letters_ascii  = range(ord('A'), ord('Z')+1)
upper_letters  = list(chr(l) for l in letters_ascii)
combine_letter = [chr(m) + chr(n) for m in letters_ascii for n in letters_ascii]
upper_letters.extend(combine_letter)
excel_sheet_head = upper_letters.copy()
print(excel_sheet_head)

5.7 三人行 ： pass、 del和exec。

5.7.1 什么都不做: 有时候什么都不用做。这种情况不多，但一旦遇到，知道可使用pass语句大有裨益。
>>> pass
>>>

if name == 'Ralph Auldus Melish':
	print('Welcome!')
elif name == 'Enid':
	# 还未完成……
	pass
elif name == 'Bill Gates':
	print('Access Denied')
	
5.7.2 使用 del 删除

	对于你不再使用的对象， Python通常会将其删除（因为没有任何变量或数据结构成员指向它） 。
	
5.7.3 使用 exec 和 eval 执行字符串及计算其结果

1. exec : 函数exec将字符串作为代码执行。
>>> exec("print('Hello, world!')")
Hello, world!

2. eval: eval是一个类似于exec的内置函数。 exec执行一系列Python语句，而eval计算用字符串表示的Python表达式的值，
		并返回结果（exec什么都不返回，因为它本身是条语句）。例如，你可使用如下代码来创建一个Python计算器：
		
express = input("Enter an arithmetic expression: ")
value = eval(express)
print(value)

Enter an arithmetic expression: 1 + 2 * 3
42


第6章 抽象

	本章介绍如何将语句组合成函数

6.1 懒惰是一种美德
	提取一个功能到一个函数中.
	
6.2 抽象和结构
	抽象可节省人力，但实际上还有个更重要的优点：抽象是程序能够被人理解的关键所在（无论对编写程序还是阅读程序来说，这都至关重要）。

6.3 自定义函数
>>> callable(abs)
True
>>> callable(value)
False
>>> 

def hello(name):
	return 'Hello, ' + name + '!'
	
6.3.1 给函数编写文档	

def square(x):
	'Calculates the square of the number x.'
	return x * x	
	
print('square.__doc__ : ' , square.__doc__)

6.3.2 其实并不是函数的函数(类似过程的概念)

	警告 不要让这种默认行为带来麻烦。如果你在if之类的语句中返回值，务必确保其他分支也返回值，以免在调用者期望函数返回一个序列时（举个例子），不小心返回了None。
	
6.4 参数魔法
	
1. python中的函数应从函数返回所有需要的值（如果需要返回多个值，就以元组的方式返回它们）。	


	有时候，参数的排列顺序可能难以记住，尤其是参数很多时。为了简化调用工作，可指定参数的名称。
	
def hello_1(greeting, name):
	print('{}, {}!'.format(greeting, name))

>>>hello_1(greeting='Hello', name='world')
Hello, world!  
	在这里，参数的顺序无关紧要。
	
>>> store('Mr. Brainsample', 10, 20, 13, 5)
可以像下面这样做：
>>> store(patient='Mr. Brainsample', hour=10, minute=20, day=13, month=5)
然而，关键字参数最大的优点在于，可以指定默认值。

def hello_3(greeting='Hello', name='world'):
	print('{}, {}!'.format(greeting, name))

	像这样给参数指定默认值后，调用函数时可不提供它！可以根据需要，一个参数值也不提供、提供部分参数值或提供全部参数值。
	
6.4.4 收集参数
	
def print_params(*params):
	print(params)	
	
>>>print_params('Testing')
('Testing',)	

>>> print_params(1, 2, 3)
(1, 2, 3)
	
def print_params_2(title, *params):
	print(title)
	print(params)
	
并尝试调用它：
>>> print_params_2('Params:', 1, 2, 3)
Params:
(1, 2, 3)
	因此星号意味着收集余下的位置参数。如果没有可供收集的参数， params将是一个空元组。
>>>print_params_2('Nothing:')
Nothing:
()	

	要收集关键字参数，可使用两个星号。
>>> def print_params_3(**params):
... print(params)
...
>>> print_params_3(x=1, y=2, z=3)
{'z': 3, 'x': 1, 'y': 2}
	如你所见，这样得到的是一个字典而不是元组。可结合使用这些技术。
	
6.4.5 分配参数

def add(x, y):
	return x + y
	
params = (1, 2)
>>>add(*params)
3

	因此，只有在定义函数（允许可变数量的参数） 或调用函数时（拆分字典或序列）使用，星号才能发挥作用。
	
6.5 作用域

	变量到底是什么呢？可将其视为指向值的名称。因此，执行赋值语句x = 1后，名称x指向值1。这几乎与使用字典时一样（字典中的键指向值），
	只是你使用的是“看不见”的字典。实际上，这种解释已经离真相不远。有一个名为vars的内置函数，它返回这个不可见的字典：
>>> x = 1
>>> scope = vars()
>>> scope['x']
1
>>> scope['x'] += 1
>>> x
2

6.6 递归

6.7.1 本章介绍的新函数

函数 									描述
-------------------------------------------------------------------------------------
map(func, seq[, seq, ...]) 			对序列中的所有元素执行函数
filter(func, seq) 					返回一个列表，其中包含对其执行函数时结果为真的所有元素
reduce(func, seq[, initial]) 		等价于 func(func(func(seq[0], seq[1]), seq[2]), ...)
sum(seq) 							返回 seq 中所有元素的和
apply(func[, args[, kwargs]]) 		调用函数（还提供要传递给函数的参数）
-------------------------------------------------------------------------------------

1. map函数
map()函数接收两个参数，一个是函数，一个是 Iterable，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator 返回。

>>> l = list(range(1, 10))
>>> def f(x):
...     return x * x
... 
>>> r = map(f, l)
>>> print(list(l))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> 

不需要 map()函数，写一个循环，也可以计算出结果：
L = []
for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:
L.append(f(n))
print(L)
但是，从上面的循环代码，能一眼看明白“把 f(x)作用在 list的每一个元素并把结果生成一个新的 list”吗？
所以， map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的 f(x)=x2，还可以计算任意复杂的函数，比如，把这个
list 所有数字转为字符串：
>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
只需要一行代码。

2. reduce函数

reduce 把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数， reduce 把结果继续和序列的下一个元
素做累积计算，其效果就是：
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
比方说对一个序列求和，就可以用 reduce 实现：
>>> from functools import reduce
>>> def add(x, y):
	... return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25
当然求和运算可以直接用 Python 内建函数 sum()，没必要动用 reduce。但是如果要把序列[1, 3, 5, 7, 9]变换成整数 13579， reduce 就可以派上用场

>>> from functools import reduce
>>> def fn(x, y):
... return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
这个例子本身没多大用处，但是，如果考虑到字符串 str 也是一个序列，对上面的例子稍加改动，配合 map()，我们就可以写出把 str 转换为 int的函数：
>>> from functools import reduce
>>> def fn(x, y):
	... return x * 10 + y
...
>>> def char2num(s):
... 	return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
...
>>> reduce(fn, map(char2num, '13579'))
13579
整理成一个 str2int 的函数就是：
from functools import reduce
def str2int(s):
	def fn(x, y):
		return x * 10 + y
	def char2num(s):
		return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
	return reduce(fn, map(char2num, s))
	
还可以用 lambda 函数进一步简化成：
from functools import reduce
def char2num(s)
	return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
def str2int(s):
	return reduce(lambda x, y: x * 10 + y, map(char2num, s))
	
也就是说，假设 Python 没有提供 int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！

3. sum函数 : sum()函数可以接受一个list并求和
>>> l = list(range(1, 10))
>>> sum(l)
45

4. filter函数: filter()函数用于过滤序列。
	和 map()类似， filter()也接收一个函数和一个序列。和 map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是 True 还
	是 False 决定保留还是丢弃该元素。例如，在一个 list 中，删掉偶数，只保留奇数，可以这么写：

def is_odd(n):
	return n % 2 == 1
		
list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]	

5. apply函数: 

	apply(func [, args [, kwargs ]]) 函数用于当函数参数已经存在于一个元组或字典中时，间接地调用函数。args是一个包含将要提供给函数
	的按位置传递的参数的元组。如果省略了args，任 何参数都不会被传递，kwargs是一个包含关键字参数的字典。 
	apply()的返回值就是func()的返回值，apply()的元素参数是有序的，元素的顺序必须和func()形式参数的顺序一致

下面给几个例子来详细的说下:
 1)、假设是执行没有带参数的方法
 
def say():
  print('say in')

apply(say)
 
输出的结果是'say in'
 

2)、函数只带元组的参数。
 
def say(a, b):
  print(a, b)
 
apply(say, ("hello", "老王python"))
 
输出的结果是hello,老王python
 
3)、函数带关键字参数。
 
def say(a=1, b=2):
  print(a, b)
 
def haha(**kw):
  #say(kw)
  apply(say, (), kw)
 
print(haha(a='a', b='b'))
 
输出的结果是:a,b

6. 匿名函数
	在 Python 中，对匿名函数提供了有限支持。还是以 map()函数为例，计算 f(x)=x2 时，除了定义一个 f(x)的函数外，还可以直接传入匿名函数：
	>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
	[1, 4, 9, 16, 25, 36, 49, 64, 81]
	
	通过对比可以看出，匿名函数 lambda x: x * x 实际上就是：
	def f(x):
		return x * x
		
	关键字lambda表示匿名函数，冒号前面的x表示函数参数

	匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果。
	用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：
	>>> f = lambda x: x * x
	>>> f
	<function <lambda> at 0x101c6ef28>
	>>> f(5)
	25
		
	同样，也可以把匿名函数作为返回值返回，比如：
	def build(x, y):
		return lambda: x * x + y * y
		
7. 装饰器

	现在，假设我们要增强 now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改 now()函数的定义，这种在代码运行期间动
	态增加功能的方式，称之为“装饰器”（ Decorator）。

	本质上， decorator 就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的 decorator，可以定义如下：
	def log(func):
		def wrapper(*args, **kw):
			print('call %s():' % func.__name__)
				return func(*args, **kw)
		return wrapper

@log
def now():
	print('2015-3-25')
	
调用 now()函数，不仅会运行 now()函数本身，还会在运行 now()函数前打印一行日志：
>>> now()
call now():
2015-3-25
把@log 放到 now()函数的定义处，相当于执行了语句：
now = log(now)
	
		

第7章  类: 再谈抽象

7.1 对象魔法
	在面向对象编程中，术语对象大致意味着一系列数据（属性）以及一套访问和操作这些数据的方法。使用对象而非全局变量和函数的原因有多个，
	下面列出了使用对象的最重要的好处。
	 	封装：对外部隐藏有关对象工作原理的细节。
	 	继承：可基于通用类创建出专用类。
		多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行。	

7.2 类

7.2.1 类到底是什么
	本书前面反复提到了类，并将其用作类型的同义词。从很多方面来说，这正是类的定义---一种对象。每个对象都属于特定的类，并被称为该类的实例。
	
	注意 在英语日常交谈中，使用复数来表示类，如birds（鸟类）和larks（云雀） 。在Python中，约定使用单数并将首字母大写，如Bird和Lark。
	
7.2.2 创建自定义类

class Person:
	def set_name(self, name):
		self.name = name
		
	def get_name(self):
		return self.name
		
	def greet(self):
		print("Hello, world! I'm {}.".format(self.name))
		
person = Person()
person.set_name('zwj')
person.greet()


7.4.1 本章介绍的新函数

函数 									描述
-----------------------------------------------------------------
callable(object) 					判断对象是否是可调用的（如是否是函数或方法）
getattr(object,name[,default]) 		获取属性的值，还可提供默认值
hasattr(object, name) 				确定对象是否有指定的属性
isinstance(object, class) 			确定对象是否是指定类的实例
issubclass(A, B) 					确定A是否是B的子类
random.choice(sequence) 			从一个非空序列中随机地选择一个元素
setattr(object, name, value) 		将对象的指定属性设置为指定的值
type(object) 						返回对象的类型

第8章  异常

8.1 异常是什么

8.2 让事情沿你指定的轨道出错

8.2.1 raise 语句
8.2.2 自定义的异常类
8.3 捕获异常
8.4 异常和函数

第9章 魔法方法、特性和迭代器

9.1 如果你使用的不是Python 3

9.2 构造函数: __init__

class Date:
	def __init__(self):
		self.__year  = 1999
		self.__month = 9
		self.__day   = 9
		self.__date  = '1999-9-9'
				
	def set_date(self, y, m, d):
		self.__year  = y
		self.__month = m
		self.__day   = d
		self.__date = "{}-{}-{}".format(self.__year, self.__month, self.__day)		
		
	def get_date(self):
		return self.__date
		
	def show(self):
		print('The date is :' + self.__date)
		
		  
date = Date()
date.show()
date.set_date(2018, 4, 22)
date.show()

9.2.1 重写普通方法和特殊的构造函数
class Bird:
	def __init__(self):
		self.hungry = True
		
	def eat(self):
		if self.hungry:
			print('Aaaah ...')
			self.hungry = False
		else:
			print('No, thanks!')	
			
		
>>> b = Bird()
>>> b.eat()
Aaaah ...
>>> b.eat()
No, thanks!

从这个示例可知，鸟进食后就不再饥饿。下面来看子类SongBird，它新增了鸣叫功能。
class SongBird(Bird):
	def __init__(self):
		self.sound = 'Squawk!'
		
	def sing(self):
		print(self.sound)
		
SongBird类使用起来与Bird类一样容易：

>>> sb = SongBird()
>>> sb.sing()
Squawk!

SongBird是Bird的子类，继承了方法eat，但如果你尝试调用它，将发现一个问题。
>>> sb.eat()
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "birds.py", line 6, in eat
if self.hungry:
AttributeError: SongBird instance has no attribute 'hungry

9.2.2 调用未关联的超类构造函数
本节介绍的方法主要用于解决历史遗留问题。

class SongBird(Bird):
    def __init__(self):
        Bird.__init__(self)
        self.sound = 'Squawk!'
    
    def sing(self):
        print(self.sound)
        
在SongBird类中，只添加了一行，其中包含代码Bird.__init__(self)。先来证明这确实管用，再解释这到底意味着什么。
>>> sb = SongBird()
>>> sb.sing()
Squawk!
>>> sb.eat()
Aaaah ...
>>> sb.eat()
No, thanks!

9.2.3 使用函数 super
如果你使用的不是旧版Python，就应使用函数super。

class Bird:
    def __init__(self):
        self.hungry = True

    def eat(self):
        if self.hungry:
            print('Aaaah ...')
            self.hungry = False
        else:
            print("No, thanks")

class SongBird(Bird):
    def __init__(self):
        super().__init__()
        self.sound = 'Squawk!'

    def sing(self):
        print(self.sound)

sb = SongBird()
sb.sing()
sb.eat()
sb.eat()	

9.3 元素访问
    虽然__init__无疑是你目前遇到的最重要的特殊方法，但还有不少其他的特殊方法，让你能够完成很多很酷的任务。
    本节将介绍一组很有用的魔法方法，让你能够创建行为类似于序列或映射的对象。

9.5 特性

9.5.1 函数 property

class Rectangle:
    def __init__ (self):
        self.width  = 10
        self.height = 20

    def set_size(self, size):
        self.width, self.height = size

    def get_size(self):
        return self.width, self.height

    size = property(get_size, set_size)

r = Rectangle()
print(r.size)
r.size = (150, 100)
print(r.size)

Python 内置的@property 装饰器就是负责把一个方法变成属性调用的：

class Student(object):
	@property
	def score(self):
		return self._score
		
	@score.setter
	def score(self, value):
		if not isinstance(value, int):
			raise ValueError('score must be an integer!')
		if value < 0 or value > 100:
			raise ValueError('score must between 0 ~ 100!')
			
		self._score = value


class Student(object):
	@property
	def birth(self):
		return self._birth
		
	@birth.setter
	def birth(self, value):
		self._birth = value
		
	@property
	def age(self):
		return 2015 - self._birth
	
上面的 birth 是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来


******** 使用枚举类  **************
from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

for name, member in Month.__members__.items():
	print(name, '=>', member, ',', member.value)
	
value 属性则是自动赋给成员的 int 常量，默认从 1 开始计数。如果需要更精确地控制枚举类型， 可以从 Enum 派生出自定义类：
from enum import Enum, unique

@unique
class Weekday(Enum):
	Sun = 0 # Sun 的 value 被设定为 0
	Mon = 1
	Tue = 2
	Wed = 3
	Thu = 4
	Fri = 5
	Sat = 6
	
@unique 装饰器可以帮助我们检查保证没有重复值。

访问这些枚举类型可以有若干种方法：
>>> day1 = Weekday.Mon
>>> print(day1)
Weekday.Mon
>>> print(Weekday.Tue)
Weekday.Tue
>>> print(Weekday['Tue'])
Weekday.Tue
>>> print(Weekday.Tue.value)
2
>>> print(day1 == Weekday.Mon)
True
>>> print(day1 == Weekday.Tue)
False
>>> print(Weekday(1))
Weekday.Mon
>>> print(day1 == Weekday(1))
True
>>> Weekday(7)
Traceback (most recent call last):
...
ValueError: 7 is not a valid Weekday
>>> for name, member in Weekday.__members__.items():
... print(name, '=>', member)
...
Sun => Weekday.Sun
Mon => Weekday.Mon
Tue => Weekday.Tue
Wed => Weekday.Wed
Thu => Weekday.Thu
Fri => Weekday.Fri
Sat => Weekday.Sat

可见，既可以用成员名称引用枚举常量，又可以直接根据 value 的值获得枚举常量。

9.5.2 静态方法和类方法		

静态方法的定义中没有参数self，可直接通过类来调用。类方法的定义中包含类似于self的参数，通常被命
名为cls。对于类方法，也可通过对象直接调用，但参数cls将自动关联到类。

class MyClass:
    @staticmethod
    def smeth():
        print('This is a static method')
        
    @classmethod
    def cmeth(cls):
        print('This is a class method of', cls)
        
MyClass.smeth()
MyClass.cmeth()

result:
This is a static method
This is a class method of <class '__main__.MyClass'>

9.6 生成器
    如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的 list，
	从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器： generator。
	
	创建generator第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个 generator：
>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
创建 L 和 g 的区别仅在于最外层的[]和()， L 是一个 list，而 g 是一个generator。
我们可以直接打印出 list 的每一个元素，但我们怎么打印出 generator 的每一个元素呢？
如果要一个一个打印出来，可以通过 next()函数获得 generator 的下一个返回值：
>>> next(g)
0
>>> next(g)
1
>>> next(g)
4
>>> next(g)	

generator 保存的是算法，每次调用 next(g)，就计算出 g 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration 的错误。

方法2: 使用for 循环，因为 generator 也是可迭代对象
>>> g = (x * x for x in range(10))
>>> for n in g:
... 	print(n)
...

创建了一个 generator 后，基本上永远不会调用 next()，而是通过 for 循环来迭代它，并且不需要关心 StopIteration 的错误。


斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：
def fib(max):
	n, a, b = 0, 0, 1
	while n < max:
		print(b)
		a, b = b, a + b
		n = n + 1
	return 'done'
	
仔细观察，可以看出， fib 函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似 generator。	

要把fib函数变成generator，只需要把 print(b)改为 yield b 就可以了：
def fib(max):
	n, a, b = 0, 0, 1
	while n < max:
		yield b
		a, b = b, a + b
		n = n + 1
	return 'done'
	
这就是定义 generator 的另一种方法。如果一个函数定义中包含 yield 关键字，那么这个函数就不再是一个普通函数，而是一个generator:
>>> f = fib(6)
>>> f
<generator object fib at 0x104feaaa0>

>>> type(fib)
<class 'function'>
>>> f = fib(10)
>>> type(f)
<class 'generator'>

这里，最难理解的就是 generator 和函数的执行流程不一样。函数是顺序执行，遇到 return 语句或者最后一行函数语句就返回。
而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

举个简单的例子，定义一个 generator，依次返回数字 1， 3， 5：
def odd():
	print('step 1')
	yield 1
	print('step 2')
	yield(3)
	print('step 3')
	yield(5)

调用该 generator 时，首先要生成一个 generator 对象，然后用 next()函数不断获得下一个返回值：
>>> o = odd()
>>> next(o)
step 1
1
>>> next(o)
step 2
3
>>> next(o)
step 3
5
>>> next(o)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
StopIteration

请注意区分普通函数和 generator 函数，普通函数调用直接返回结果：
>>> r = abs(6)
>>> r
6
generator 函数的“调用”实际返回一个 generator 对象：
>>> g = fib(6)
>>> g
<generator object fib at 0x1022ef948>

9.7 迭代器

    注意 更正规的定义是，实现了方法__iter__的对象是可迭代的，而实现了方法__next__的对象是迭代器。
	
我们已经知道，可以直接作用于 for 循环的数据类型有以下几种：一类是集合数据类型，如 list、 tuple、 dict、 set、 str 等；
一类是 generator，包括生成器和带 yield 的 generator function。这些可以直接作用于 for 循环的对象统称为可迭代对象： Iterable。
可以使用 isinstance()判断一个对象是否是 Iterable 对象：
>>> from collections import Iterable
>>> isinstance([], Iterable)
True
>>> isinstance({}, Iterable)
True
>>> isinstance('abc', Iterable)
True
>>> isinstance((x for x in range(10)), Iterable)	
True
>>> isinstance(100, Iterable)
False

而生成器不但可以作用于 for 循环，还可以被 next()函数不断调用并返回下一个值，直到最后抛出 StopIteration 错误表示无法继续返回下一个
值了。可以被 next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

可以使用 isinstance()判断一个对象是否是 Iterator 对象

>>> from collections import Iterator
>>> isinstance((x for x in range(10)), Iterator)
True
>>> isinstance([], Iterator)
False
>>> isinstance({}, Iterator)
False
>>> isinstance('abc', Iterator)
False

生成器都是 Iterator 对象，但 list、 dict、 str 虽然是 Iterable，却不是Iterator。

把 list、 dict、 str 等 Iterable 变成 Iterator 可以使用 iter()函数：
>>> isinstance(iter([]), Iterator)
True
>>> isinstance(iter('abc'), Iterator)
True

为什么 list、 dict、 str 等数据类型不是 Iterator？这是因为 Python 的 Iterator 对象表示的是一个数据流， 
Iterator 对象可以被 next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration 错误。
可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next()函数实现按需计算下一
个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator 甚至可以表示一个无限大的数据流，
例如全体自然数。而使用list 是永远不可能存储全体自然数的。

小结
凡是可作用于 for 循环的对象都是 Iterable 类型；凡是可作用于 next()函数的对象都是 Iterator 类型，它们表示一个惰性
计算的序列；集合数据类型如 list、 dict、 str 等是 Iterable 但不是 Iterator，不过可以通过 iter()函数获得一个 Iterator 对象。
Python 的 for 循环本质上就是通过不断调用 next()函数实现的，例如：
for x in [1, 2, 3, 4, 5]:
	pass
	
实际上完全等价于：
# 首先获得 Iterator 对象:
it = iter([1, 2, 3, 4, 5])

# 循环:
while True:
	try:
		# 获得下一个值:
		x = next(it)
	except StopIteration:
		# 遇到 StopIteration 就退出循环
		break

第10章 开箱即用

10.1 模块
>>> import math
>>> math.sin(0)
0.0

10.1.2 模块是用来下定义的
    1. 在模块中定义函数
    2. 在模块中添加测试代码
    
    一个包含有条件地执行的测试代码的模块
# hello4.py
def hello():
    print("Hello, world!")
def test():
    hello()
    
if __name__ == '__main__': test()
    
10.1.3 让模块可用
    1. 将模块放在正确的位置
    
>>> import sys, pprint
>>> pprint.pprint(sys.path)
['C:\\Python35\\Lib\\idlelib',
'C:\\Python35',
'C:\\Python35\\DLLs',
'C:\\Python35\\lib',
'C:\\Python35\\lib\\plat-win',
'C:\\Python35\\lib\\lib-tk',
'C:\\Python35\\lib\\site-packages'

2. 告诉解释器到哪里去查找

10.1.4 包
为组织模块，可将其编组为包（package） 。包其实就是另一种模块，但有趣的是它们可包含其
他模块。模块存储在扩展名为.py的文件中，而包则是一个目录。要被Python视为包，目录必须包含
文件__init__.py。如果像普通模块一样导入包，文件__init__.py的内容就将是包的内容。例如，如果
有一个名为constants的包，而文件constants/__init__.py包含语句PI = 3.14，就可以像下面这样做：
import constants
print(constants.PI)
要将模块加入包中，只需将模块文件放在包目录中即可。你还可以在包中嵌套其他包。例如，
要创建一个名为drawing的包，其中包含模块shapes和colors，需要创建如表10-1所示的文件和目
录（UNIX路径名）。    

10.2 探索模块

10.2.1 模块包含什么
1. 使用dir
2. 变量__all_

10.3 标准库：一些深受欢迎的模块
10.3.1 sys
模块sys让你能够访问与Python解释器紧密相关的变量和函数，

模块sys中一些重要的函数和变量
函数/变量 描 述
argv 命令行参数，包括脚本名
exit([arg]) 退出当前程序，可通过可选参数指定返回值或错误消息
modules 一个字典，将模块名映射到加载的模块
path 一个列表，包含要在其中查找模块的目录的名称
platform 一个平台标识符，如sunos5或win32
stdin 标准输入流——一个类似于文件的对象
stdout 标准输出流——一个类似于文件的对象
stderr 标准错误流——一个类似于文件的对象


10.3.2 os
模块os让你能够访问多个操作系统服务。

模块os中一些重要的函数和变量
函数/变量 描 述
environ 包含环境变量的映射
system(command) 在子shell中执行操作系统命令
sep 路径中使用的分隔符
pathsep 分隔不同路径的分隔符
linesep 行分隔符（'\n'、 '\r'或'\r\n'）
urandom(n) 返回n个字节的强加密随机数据


10.3.3 fileinput
模块fileinput中一些重要的函数
函 数 描 述
input([files[, inplace[, backup]]]) 帮助迭代多个输入流中的行
filename() 返回当前文件的名称
lineno() 返回（累计的）当前行号
filelineno() 返回在当前文件中的行号
isfirstline() 检查当前行是否是文件中的第一行
isstdin() 检查最后一行是否来自sys.stdin
nextfile() 关闭当前文件并移到下一个文件
close() 关闭序列










