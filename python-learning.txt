第一章 快速上手：基础知识

1.1 基础
	1. 整型数据类型没有长度限制
		a = 999999999999999999999999999999999999999999999999999999
	
	2. / : 除法运算的结果为小数，即浮点数（float或floating-point number）。
		1 / 2 = 0.5
		1 / 1 = 1.0
	
	3. // : 整除运算，可使用双斜杠
		1   // 2   = 0
		1   // 1   = 1
		5.0 // 2.4 = 2.0
		-10 // 3  = -4
		
	4. % : 求余（求模）运算符
		10   % 3    = 1
		2.75 % 0.5  = 0.25
		
	5. **: 乘方（求幂）运算符
		2 ** 3    = 8
		-3 ** 2   = -9
		(-3) ** 2 = 9
		
	6. 十六进制(0x)和二进制(0b)
		>>> 0xAF
		175
		>>> 0b1011010010
		722
		
	7. 获取用户输入
		x = input("x: ")
	
	8. 输出
		print(x)
		print('x = ' + input("x: "))
		print('x = ', input("x: "))
		
	9. 模块
	可将模块视为扩展，通过将其导入可以扩展Python功能。要导入模块，可使用特殊命令
		>>> import math
		>>> math.floor(32.9)
		32
		
		>>> import cmath
		>>> cmath.sqrt(-1)
		1j
		
	10. 强大的海龟绘图法
		from turtle import *
		forward(100)
		left(120)
		forward(100)
		left(120)
		forward(100)
		
	11. 从命令提示符运行 Python 脚本
	在Windows中使用如下命令来执行这个脚本：		
		C:\>python hello.py
	在UNIX系统中，可使用如下命令：
		$ python hello.py
		
	12. 让脚本像普通程序一样
		$ gedit hello.py
			#!/usr/bin/env python
			print('Hello,' + input('What is your name?'))
			input('Press <enter>')
			
		$ chmod a+x hello.py
		$./hello.py
		
1.2 input和print函数
	1. input函数输入字符串
		num = int(input('Enter a number: '))   # int(str) : 把字符串str转换为int
	
	2. print函数: 输出n个字符串(n >= 1)

		
第二章 列表和元组

2.1 序列概述
	Python内置了多种序列，本章重点讨论其中最常用的两种： 列表和元组。另一种重要的序列是字符串，将在下一章更详细地讨论。
	列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于
	某种考虑需要禁止修改序列的情形。禁止修改序列通常出于技术方面的考虑，与Python的内部工作原理相关，这也是有些内置函数
	返回元组的原因所在。在你自己编写程序时，几乎在所有情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键，
	在这种情况下，不能使用列表来代替元组，因为字典键是不允许修改的。在需要处理一系列值时，序列很有用。在数据库中，可能使用
	序列来表示人，其中第一个元素为姓名，而第二个元素为年龄。如果使用列表来表示（所有元素都放在方括号内，并用逗号
	隔开），将类似于下面这样：
		>>> edward = ['Edward Gumby', 42]
		
	序列还可包含其他序列，因此可创建一个由数据库中所有人员组成的列表：
		>>> edward = ['Edward Gumby', 42]
		>>> john = ['John Smith', 50]
		>>> database = [edward, john]
		>>> database
		[['Edward Gumby', 42], ['John Smith', 50]]		
		
	注意: Python支持一种数据结构的基本概念，名为容器（container） 。容器基本上就是可包含其他对象的对象。
	两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。
	有一种既不是序列也不是映射的容器，它就是集合（set）

2.2 通用的序列操作

	有几种操作适用于所有序列，包括索引、 切片、 相加、 相乘和成员资格检查。另外， Python还提供了一些内置函数，
	可用于确定序列的长度以及找出序列中最大和最小的元素

2.2.1 索引
	序列中的所有元素都有编号——从0开始递增。

	正索引: 0           ~ (序列长度) -1
	负索引: -(序列长度)  ~  -1

	greeting = 'Hello'
	greeting[0] = 'H'
	greeting[4] = 'o'
	
    对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作
 	'Hello'[0]  = 'H'
  	'Hello'[-1] = 'o'

2.2.2 切片操作 (步长默认为1)
   第一个索引是包含的第一个元素的编号，但第二个索引是切片后余下的第一个元素的编号
  
   a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  (10个元素)
      
   1. 绝妙的简写	  
	   a[0] = a[-10] = 0
	   a[9] = a[-1]  = 9
	   a[0:10] :  取出全部元素(正数索引)
	   a[-10:] :  取出全部元素(负数索引)

	   如果切片始于序列开头，可省略第一个索引。
	   a[:3] = [0, 1, 2]

	   如果切片结束于序列末尾，可省略第二个索引。
	   a[-3:] = [7, 8, 9]

	   要复制整个序列，可将两个索引都省略。
	   a[:] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
   
	2. 更大的步长
		a) 取出偶数
			even = a[0:10:2]
			even = a[::2]

		b) 取出奇数
			odd = a[1:10:2]
			
	显式地指定步长时，也可使用前述简写。例如，要从序列中每隔3个元素提取1个，只需提供步长4即可。
		>>> numbers[::4]
		[1, 5, 9]
		
	当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素。 (在这种情况下，要正确地提取颇费思量。)
		>>> numbers[8:3:-1]
		[9, 8, 7, 6, 5]
		>>> numbers[10:0:-2]
		[10, 8, 6, 4, 2]
		>>> numbers[0:10:-2]
		[]
		>>> numbers[::-2]
		[10, 8, 6, 4, 2]		
		
		>>> numbers[5::-2]
		[6, 4, 2]
		>>> numbers[:5:-2]
		[10, 8]		

2.2.3 序列相加 	可使用加法运算符来拼接序列。
		>>> [1, 2, 3] + [4, 5, 6]
		[1, 2, 3, 4, 5, 6]

2.2.4 乘法 将序列与数x相乘时，将重复这个序列x次来创建一个新序列：
		>>>'python' * 5
		'pythonpythonpythonpythonpython'
		
		>>>[42] * 10
		[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]   
		
	在有些情况下，可能想使用表示“什么都没有”的值，如表示还没有在列表中添加任何内容。在这种情况下，
	可使用None。在Python中， None表示什么都没有。因此，要将列表的长度初始化为10，可像下面这样做：
		>>> sequence = [None] * 10
		>>> sequence
		[None, None, None, None, None, None, None, None, None, None]
		
2.2.5 成员资格 	

	a) 要检查特定的值是否包含在序列中，可使用运算符in。	
		>>> permissions = 'rw'
		>>> 'w' in permissions
		True
		>>> 'x' in permissions
		False
		>>> users = ['mlh', 'foo', 'bar']
		>>> input('Enter your user name: ') in users
		Enter your user name: mlh
		True
		>>> subject = '$$$ Get rich now!!! $$$'
		>>> '$$$' in subject
		True	
   
	b) 长度、最小值和最大值
		>>> numbers = [100, 34, 678]
		>>> len(numbers)
		3
		>>> max(numbers)
		678
		>>> min(numbers)
		34
		>>> max(2, 3)
		3
		>>> min(9, 3, 2, 5)
		2
   
2.3 列表： Python 的主力

2.3.1 函数 list
	>>> list('Hello')
	['H', 'e', 'l', 'l', 'o']
	
  (可将任何序列（而不仅仅是字符串）作为list的参数)	
	
2.3.2 基本的列表操作
	1. 修改列表：给元素赋值	
		>>> x = [1, 1, 1]
		>>> x[1] = 2
		>>> x
		[1, 2, 1]
	
	2. 删除元素
		>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
		>>> del names[2]
		>>> names
		['Alice', 'Beth', 'Dee-Dee', 'Earl']		
	
	3. 给切片赋值
	a. 切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。
		>>> name = list('Perl')
		>>> name
		['P', 'e', 'r', 'l']
		>>> name[2:] = list('ar')
		>>> name
		['P', 'e', 'a', 'r']
		
	b. 使用切片赋值还可在不替换原有元素的情况下插入新元素。
		>>> numbers = [1, 5]
		>>> numbers[1:1] = [2, 3, 4]   #“替换”了一个空切片，相当于插入了一个序列。
		>>> numbers
		[1, 2, 3, 4, 5]		
		
	c. 采取相反的措施来删除切片。
		>>> numbers
		[1, 2, 3, 4, 5]
		>>> numbers[1:4] = []   # 与del numbers[1:4]等效
		>>> numbers
		[1, 5]
		
2.3.3 列表方法
	1. append	方法append用于将一个对象附加到列表末尾。
		>>> numbers = [1, 2, 3]
		>>> numbers.append(4)
		>>> numbers
		[1, 2, 3, 4]
		
		>>> numbers = [1,2,3]
		>>> numbers.append([4,5])
		>>> numbers
		[1, 2, 3, [4, 5]]		
		
		请注意，与其他几个类似的方法一样， append也就地修改列表。这意味着它不会返回修改后的新列表，而是直接修改旧列表。
		
	2. clear 方法clear就地清空列表的内容。
		>>> lst = [1, 2, 3]
		>>> lst.clear()
		>>> lst
		[]
		这类似于切片赋值语句lst[:] = []		

	3. copy 方法 copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。
		>>> a = [1, 2, 3]
		>>> b = a
		>>> b[1] = 4
		>>> a
		[1, 4, 3]
 	要让a和b指向不同的列表，就必须将b关联到a的副本。

		>>> a = [1, 2, 3]
		>>> b = a.copy()   #这类似于b = a[:]或b = list(a)，它们也都复制a。	
		>>> b[1] = 4
		>>> a
		[1, 2, 3]
		
		
	4. count 方法count计算指定的元素在列表中出现了多少次。
		>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to')
		2
		>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
		>>> x.count(1)
		2
		>>> x.count([1, 2])
		1
	
	5. extend 方法extend让你能够同时将多个值附加到列表末尾
		>>> a = [1, 2, 3]
		>>> b = [4, 5, 6]
		>>> a.extend(b)
		>>> a
		[1, 2, 3, 4, 5, 6]
		
	注意extend函数与append函数的区别


	6. index 方法index在列表中查找指定值第一次出现的索引。
		>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
		>>> knights.index('who')
		4

	7. insert 	方法insert用于将一个对象插入列表。
		>>> numbers = [1, 2, 3, 5, 6, 7]
		>>> numbers.insert(3, 'four')
		>>> numbers
		[1, 2, 3, 'four', 5, 6, 7]
	
	8. pop 方法pop按索引从列表中删除一个元素（末尾为最后一个元素），并返回这一元素。
		>>> x = [1, 2, 3]
		>>> x.pop()  #无索引参数表示删除最后一个元素
		3
		>>> x
		[1, 2]
		>>> x.pop(0)
		1
		>>> x
		[2]
		
	注意: pop是唯一既修改列表又返回一个非None值的列表方法


	9. push和pop是大家普遍接受的两种栈操作（加入和取走）的名称。 Python没有提供push，但可
	使用append来替代。方法pop和append的效果相反，因此将刚弹出的值压入（或附加）后，得到的栈将与原来相同。
		>>> x = [1, 2, 3]
		>>> x.append(x.pop())
		>>> x
		[1, 2, 3]

	10. remove 	方法remove用于删除第一个为指定值的元素。
		>>> x = ['to', 'be', 'or', 'not', 'to', 'be']
		>>> x.remove('be')
		>>> x
		['to', 'or', 'not', 'to', 'be'	
		
	注意: pop方法按索引从列表中删除一个元素, 既修改列表又返回一个非None值
		 remove方法按指定值从列表中删除该元素, 它修改列表，但不返回任何值。
		 
	11. reverse 方法reverse按相反的顺序排列列表中的元素（我想你对此应该不会感到惊讶）。
		>>> x = [1, 2, 3]
		>>> x.reverse()
		>>> x
		[3, 2, 1]

	注意到reverse修改列表，但不返回任何值（与remove和sort等方法一样）。
	
	12. 函数reversed。这个函数不返回列表，而是返回一个迭代器（迭代器将在第9章详细介绍）。你可使用list将返回的对象转换为列表。
		>>> x = [1, 2, 3]
		>>> list(reversed(x))
		[3, 2, 1]
		 
	13. sort 方法sort用于对列表就地排序①。就地排序意味着对原来的列表进行修改，使其元素按顺序排列，
		而不是返回排序后的列表的副本。
		而不是返回排序后的列表的副本。
		而不是返回排序后的列表的副本。
		
		>>> x = [4, 6, 2, 1, 7, 9]					>>> x = [4, 6, 2, 1, 7, 9]
		>>> x.sort()								>>> y = x.copy()
		>>> x										>>> y.sort()
		[1, 2, 4, 6, 7, 9]							>>> x				
													[4, 6, 2, 1, 7, 9]
													>>> y
													[1, 2, 4, 6, 7, 9]	
	
	14. 非列表排序函数:sorted	为获取排序后的列表的副本，另一种方式是使用函数sorted。
		>>> x = [4, 6, 2, 1, 7, 9]
		>>> y = sorted(x)
		>>> x
		[4, 6, 2, 1, 7, 9]
		>>> y
		[1, 2, 4, 6, 7, 9]

	实际上，sorted函数用于可迭代的对象，但总是返回一个列表②。
	
	15. 高级排序 方法sort接受两个可选参数： key和reverse。这两个参数通常是按名称指定的，称为关键字参数
	参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比
	另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，
	可将参数key设置为函数len。
	
		>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate']
		>>> x.sort(key=len)
		>>> x
		['add', 'acme', 'aerate', 'abalone', 'aardvark']
			
		对于另一个关键字参数reverse，只需将其指定为一个真值（True或False），以指出是否要按相反的顺序对列表进行排序。			
		>>> x = [4, 6, 2, 1, 7, 9]
		>>> x.sort(reverse=True)
		>>> x
		[9, 7, 6, 4, 2, 1]
		
	函数sorted也接受参数key和reverse。


2.4 元组：不可修改的序列
	与列表一样，元组也是序列，唯一的差别在于元组是不能修改的（你可能注意到了，字符串也不能修改）。元组语法很简单，
	只要将一些值用逗号分隔，就能自动创建一个元组。
		>>> 1, 2, 3
		(1, 2, 3)

	元组还可用圆括号括起（这也是通常采用的做法）。
		>>> (1, 2, 3)
		(1, 2, 3)

	空元组用两个不包含任何内容的圆括号表示。
		>>> ()
		()
		
	如何表示只包含一个值的元组呢？这有点特殊：虽然只有一个值，也必须在它后面加上逗号。
		>>> 42
		42
		>>> 42,
		(42,)	
		>>> (42,)
		(42,)
		
	最后两个示例创建的元组长度为1，而第一个示例根本没有创建元组。逗号至关重要，仅将
	值用圆括号括起不管用： (42)与42完全等效。但仅仅加上一个逗号，就能完全改变表达式的值。
		>>> 3 * (40 + 2)
		126
		>>> 3 * (40 + 2,)
		(42, 42, 42)
	
	函数tuple的工作原理与list很像：它将一个序列作为参数，并将其转换为元组①。如果参数已经是元组，就原封不动地返回它。
		>>> tuple([1, 2, 3])
		(1, 2, 3)
		>>> tuple('abc')
		('a', 'b', 'c')
		>>> tuple((1, 2, 3))
		(1, 2, 3)

	你可能意识到了，元组并不太复杂，而且除创建和访问其元素外，可对元组执行的操作不多。
	元组的创建及其元素的访问方式与其他序列相同。
		>>> x = (1, 2, 3)  # x = 1, 2, 3
		>>> x[1]
		2
		>>> x[0:2]
		(1, 2)	

	元组的切片也是元组，就像列表的切片也是列表一样。为何要熟悉元组呢？原因有以下两个。
	1)它们用作映射中的键（以及集合的成员），而列表不行。映射将在第4章详细介绍。
	2)有些内置函数和方法返回元组，这意味着必须跟它们打交道。只要不尝试修改元组，与
	元组“打交道”通常意味着像处理列表一样处理它们（需要使用元组没有的index和count等方法时例外）。
	
	一般而言，使用列表足以满足对序列的需求。
	
	2.5.1 本章介绍的新函数
	
	---------------------------------
	函 数				 	描 述
	---------------------------------
	len(seq) 			返回序列的长度
	list(seq) 			将序列转换为列表
	max(args) 			返回序列或一组参数中的最大值
	min(args) 			返回序列和一组参数中的最小值
	reversed(seq) 		能够反向迭代序列
	sorted(seq) 		返回一个有序列表，其中包含指定序列中的所有元素
	tuple(seq) 			将序列转换为元组

第3章 使用字符串

3.1 字符串基本操作
	
	所有标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串，
	但别忘了字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的。

3.2 设置字符串的格式：精简版
	
	将值转换为字符串并设置其格式是一个重要的操作，
	1) 主要的解决方案是使用字符串格式设	置运算符——百分号。这个运算符的行为类似于C语言中的经典函数printf：在%左边指定一个字
	符串（格式字符串），并在右边指定要设置其格式的值。
	2) 指定要设置其格式的值时，可使用单个值（如字符串或数字）,可使用元组（如果要设置多个值的格式），还可使用字典，其中最常见的是元组。
		>>>format = "Hello, %s. %s enough for you?" 
		>>>values = ('world', 'Hot')
		>>>format % values
		'Hello, world. Hot enough for you?'
		
	上述格式字符串中的%s称为转换说明符，指出了要将值插入什么地方。 

	3) 编写新代码时，应选择使用字符串方法format，它融合并强化了早期方法的优点。使用这种方法时，
	每个替换字段都用花括号括起，其中可能包含名称，还可能包含有关如何对相应的值进行转换和格式设置的信息。
	在最简单的情况下，替换字段没有名称或将索引用作名称。
		>>> "{}, {} and {}".format("first", "second", "third")
		'first, second and third'
		>>> "{0}, {1} and {2}".format("first", "second", "third")
		'first, second and third'		
				
	然而，索引无需像上面这样按顺序排列。
		>>> "{3} {0} {2} {1} {3} {0}".format("be", "not", "or", "to")
		'to be or not to be'
		
	命名字段的工作原理与你预期的完全相同。
		>>> from math import pi
		>>> "{name} is approximately {value:.2f}.".format(value=pi, name="π")
		'π is approximately 3.14.'

	当然，关键字参数的排列顺序无关紧要。在这里，我还指定了格式说明符.2f，并使用冒号将其与字段名隔开。
	它意味着要使用包含2位小数的浮点数格式。如果没有指定.2f，结果将如下：
		>>> "{name} is approximately {value}.".format(value=pi, name="π")
		'π is approximately 3.141592653589793.'
		
	最后，在Python 3.6中，如果变量与替换字段同名，还可使用一种简写。在这种情况下，可
	使用f字符串——在字符串前面加上f。
		>>> from math import e
		>>> f"Euler's constant is roughly {e}."
		"Euler's constant is roughly 2.718281828459045."
		
	在这里，创建最终的字符串时，将把替换字段e替换为变量e的值。这与下面这个更明确一些的表达式等价
		>>> "Euler's constant is roughly {e}.".format(e=e)
		"Euler's constant is roughly 2.718281828459045."
		
	c = a + b :
	
		>>> a = input('input value of a:')  #  a = '1'
		>>> b = input('input value of b:')  #  b = '2'
		>>> c = int(a) + int(b)
		>>> "{} + {} = {}".format(a, b, c)   
		'1 + 2 = 3'
		
		>>>"{0} + {1} = {2}".format(a, b, c)
		'1 + 2 = 3'
		
		>>>"{a} + {b} = {c}".format(a=a, b=b, c=c)
		'1 + 2 = 3'			

3.3 设置字符串的格式：完整版

3.3.1 替换字段名
	在最简单的情况下，只需向format提供要设置其格式的未命名参数，并在格式字符串中使用未命名字段。此时，将按顺序将字段和参数配对。
	你还可给参数指定名称，这种参数将被用于相应的替换字段中。你可混合使用这两种方法。

	>>> "{foo} {} {bar} {}".format(1, 2, bar=4, foo=3)
	'3 1 4 2'
	
	>>> "{foo} {1} {bar} {0}".format(1, 2, bar=4, foo=3)
	'3 2 4 1

3.3.2 基本转换

	指定要在字段中包含的值后，就可添加有关如何设置其格式的指令了。首先，可以提供一个转换标志。
		>>> print("{pi!s} {pi!r} {pi!a}".format(pi="π"))
		π 'π' '\u03c0


	上述三个标志（s、 r和a）指定分别使用str、 repr和ascii进行转换。函数str通常创建外观普通的字符串版本（这里没有对输入字符串做任何处理）。
	函数repr尝试创建给定值的Python表示（这里是一个字符串字面量）。
	
	表3-1 字符串格式设置中的类型说明符
	  类型 含 义
		b 将整数表示为二进制数
		c 将整数解读为Unicode码点
		d 将整数视为十进制数进行处理，这是整数默认使用的说明符
		e 使用科学表示法来表示小数（用e来表示指数）
		E 与e相同，但使用E来表示指数
		f 将小数表示为定点数
		F 与f相同，但对于特殊值（nan和inf），使用大写表示
		g 自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数
		G 与g相同，但使用大写来表示指数和特殊值
		n 与g相同，但插入随区域而异的数字分隔符
		o 将整数表示为八进制数
		s 保持字符串的格式不变，这是默认用于字符串的说明符
		x 将整数表示为十六进制数并使用小写字母
		X 与x相同，但使用大写字母
		% 将数表示为百分比值（乘以100，按说明符f设置格式，再在后面加上%）


3.3.3 宽度、精度和千位分隔符

宽度是使用整数指定的，如下所示：
>>> "{num:10}".format(num=3)
' 3'
>>> "{name:10}".format(name="Bob")
'Bob

精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点。
>>> "Pi day is {pi:.2f}".format(pi=pi)
'Pi day is 3.14'

可同时指定宽度和精度。
>>> "{pi:10.2f}".format(pi=pi)
' 3.14'
实际上，对于其他类型也可指定精度，但是这样做的情形不太常见。
>>> "{:.5}".format("Guido van Rossum")
'Guido'
最后，可使用逗号来指出你要添加千位分隔符。
>>> 'One googol is {:,}'.format(10**100)
'One googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,00
0,000,000,000,000,000,000,000,000,000,000,000,000,000,000

3.3.4 符号、对齐和用 0 填充

在指定宽
度和精度的数前面，可添加一个标志。这个标志可以是零、加号、减号或空格，其中零表示使用
0来填充数字。
>>> '{:010.2f}'.format(pi)
'0000003.14'
要指定左对齐、右对齐和居中，可分别使用<、 >和^。
>>> print('{0:<10.2f}\n{0:^10.2f}\n{0:>10.2f}'.format(pi))
3.14
3.14
3.14
可以使用填充字符来扩充对齐说明符，这样将使用指定的字符而不是默认的空格来填充。
>>> "{:$^15}".format(" WIN BIG ")
'$$$ WIN BIG $$$'
还有更具体的说明符=，它指定将填充字符放在符号和数字之间。
>>> print('{0:10.2f}\n{1:10.2f}'.format(pi, -pi))
3.14
-3.14
>>> print('{0:10.2f}\n{1:=10.2f}'.format(pi, -pi))
3.14
- 3.14
如果要给正数加上符号，可使用说明符+（将其放在对齐说明符后面） ，而不是默认的-。如
果将符号说明符指定为空格，会在正数前面加上空格而不是+。
>>> print('{0:-.2}\n{1:-.2}'.format(pi, -pi)) #默认设置
3.1
-3.1
>>> print('{0:+.2}\n{1:+.2}'.format(pi, -pi))
+3.1
-3.1
>>> print('{0: .2}\n{1: .2}'.format(pi, -pi))
3.1
-3.1
需要介绍的最后一个要素是井号（#）选项，你可将其放在符号说明符和宽度之间（如果指
定了这两种设置）。这个选项将触发另一种转换方式，转换细节随类型而异。例如，对于二进制、
八进制和十六进制转换，将加上一个前缀。

>>> "{:b}".format(42)
'101010'
>>> "{:#b}".format(42)
'0b101010'
对于各种十进制数，它要求必须包含小数点（对于类型g，它保留小数点后面的零）。
>>> "{:g}".format(42)
'42'
>>> "{:#g}".format(42)
'42.0000

3.4 字符串方法

3.4.1 center
方法center通过在两边添加填充字符（默认为空格）让字符串居中。
>>> "The Middle by Jimmy Eat World".center(39)
' The Middle by Jimmy Eat World '
>>> "The Middle by Jimmy Eat World".center(39, "*")
'*****The Middle by Jimmy Eat World*****'
附录B： ljust、 rjust和zfill。
3.4.2 find
方法find在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。
>>> 'With a moo-moo here, and a moo-moo there'.find('moo')
7
>>> title = "Monty Python's Flying Circus"
>>> title.find('Monty')
0
>>> title.find('Python')
6
>>> title.find('Flying')
15
>>> title.find('Zirquss')
-1

还可指定搜索的起点和终点（它们都是可选的）。
>>> subject = '$$$ Get rich now!!! $$$'
>>> subject.find('$$$')
0
>>> subject.find('$$$', 1) # 只指定了起点
20
>>> subject.find('!!!')
16
>>> subject.find('!!!', 0, 16) # 同时指定了起点和终点
-1

3.4.3 join
join是一个非常重要的字符串方法，其作用与split相反，用于合并序列的元素。
>>> seq = [1, 2, 3, 4, 5]
>>> sep = '+'
>>> sep.join(seq) # 尝试合并一个数字列表
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: sequence item 0: expected string, int found
>>> seq = ['1', '2', '3', '4', '5']
>>> sep.join(seq) # 合并一个字符串列表
'1+2+3+4+5'
>>> dirs = '', 'usr', 'bin', 'env'
>>> '/'.join(dirs)
'/usr/bin/env'
>>> print('C:' + '\\'.join(dirs))
C:\usr\bin\env

3.4.4 lower
方法lower返回字符串的小写版本。
>>> 'Trondheim Hammer Dance'.lower()
'trondheim hammer dance

3.4.5 replace
方法replace将指定子串都替换为另一个字符串，并返回替换后的结果。
>>> 'This is a test'.replace('is', 'eez')
'Theez eez a test'

3.4.6 split
split是一个非常重要的字符串方法，其作用与join相反，用于将字符串拆分为序列。
>>> '1+2+3+4+5'.split('+')
['1', '2', '3', '4', '5']
>>> '/usr/bin/env'.split('/')
['', 'usr', 'bin', 'env']
>>> 'Using the default'.split()
['Using', 'the', 'default']

3.4.7 strip
方法strip将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果。
>>> ' internal whitespace is kept '.strip()
'internal whitespace is kept'

3.4.8 translate
方法translate与replace一样替换字符串的特定部分，但不同的是它只能进行单字符替换。
这个方法的优势在于能够同时替换多个字符，因此效率比replace高。

3.4.9 判断字符串是否满足特定的条件
很多字符串方法都以is打头，如isspace、 isdigit和isupper，它们判断字符串是否具有特定
的性质（如包含的字符全为空白、数字或大写）。如果字符串具备特定的性质，这些方法就返回
True，否则返回False。
附录B： isalnum、 isalpha、 isdecimal、 isdigit、 isidentifier、 islower、 isnumeric、
isprintable、 isspace、 istitle、 isupper。


第4章 字典: 当索引行不通时

字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。键可能是数、字符串或元组。

4.1 字典的用途

	在很多情况下，使用字典都比使用列表更合适。下面是Python字典的一些用途：
	 表示棋盘的状态，其中每个键都是由坐标组成的元组；
	 存储文件修改时间，其中的键为文件名；
	 数字电话/地址簿。

4.2 创建和使用字典

	字典由键及其相应的值组成，这种键-值对(用:分隔)称为项（item）。

	phonebook = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}
	
4.2.1 函数 dict
可使用函数dict①从其他映射（如其他字典）或键值对序列创建字典。
>>> items = [('name', 'Gumby'), ('age', 42)]
>>> d = dict(items)
>>> d
{'age': 42, 'name': 'Gumby'}
>>> d['name']
'Gumby'
还可使用关键字实参来调用这个函数，如下所示：
>>> d = dict(name='Gumby', age=42)
>>> d
{'age': 42, 'name': 'Gumby'}

4.2.2 基本的字典操作
字典的基本行为在很多方面都类似于序列。
 len(d)返回字典d包含的项（键值对）数。
 d[k]返回与键k相关联的值。
 d[k] = v将值v关联到键k。
 del d[k]删除键为k的项。
 kind 检查字典d是否包含键为k的项。

虽然字典和列表有多个相同之处，但也有一些重要的不同之处。
 键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变的类型，如浮点数（实数）、字符串或元组。
 自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。然而，如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。
 成员资格：表达式k in d（其中d是一个字典）查找的是键而不是值，而表达式v in l（其中l是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。

4.2.3 将字符串格式设置功能用于字典

使用format_map来指出你将通过一个映射来提供所需的信息。
	>>>phonebook = {'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'}
	>>>"Cecil's phone number is {Cecil}.".format_map(phonebook)
	"Cecil's phone number is 3258.

4.2.4 字典方法

1. clear
	方法clear删除所有的字典项，这种操作是就地执行的（就像list.sort一样），因此什么都不返回（或者说返回None）。
	我们来看两个场景。下面是第一个场景：
	>>> x = {}
	>>> y = x
	>>> x['key'] = 'value'
	>>> y
	{'key': 'value'}
	>>> x = {}
	>>> x = {}
	{'key': 'value'}
	下面是第二个场景：
	>>> x = {}
	>>> y = x
	>>> x['key'] = 'value'
	>>> y
	{'key': 'value'}
	>>> x.clear()
	>>> y
	{}

2. copy
	方法copy返回一个新字典，其包含的键值对与原来的字典相同（这个方法执行的是浅复制，因为值本身是原件，而非副本）。

	>>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']}
	>>> y = x.copy()
	>>> y['username'] = 'mlh'
	>>> y['machines'].remove('bar')
	>>> y
	{'username': 'mlh', 'machines': ['foo', 'baz']}
	>>> x
	{'username': 'admin', 'machines': ['foo', 'baz']}

	如你所见，当替换副本中的值时，原件不受影响。然而，如果修改副本中的值（就地修改而
	不是替换） ，原件也将发生变化，因为原件指向的也是被修改的值（如这个示例中的'machines'
	列表所示）。
	为避免这种问题，一种办法是执行深复制，即同时复制值及其包含的所有值，等等。为此，
	可使用模块copy中的函数deepcopy。
	>>> from copy import deepcopy
	>>> d = {}
	>>> d['names'] = ['Alfred', 'Bertrand']
	>>> c = d.copy()
	>>> dc = deepcopy(d)
	>>> d['names'].append('Clive')
	>>> c
	{'names': ['Alfred', 'Bertrand', 'Clive']}
	>>> dc
{'names': ['Alfred', 'Bertrand']}

3. fromkeys
	方法fromkeys创建一个新字典，其中包含指定的键，且每个键对应的值都是None。
	>>> dict.fromkeys(['name', 'age'])
	{'age': None, 'name': None}
	如果你不想使用默认值None，可提供特定的值。
	>>> dict.fromkeys(['name', 'age'], '(unknown)')
	{'age': '(unknown)', 'name': '(unknown)'}

4. get
	方法get为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。
	>>> d = {}
	>>> print(d['name'])
	Traceback (most recent call last):
	File "<stdin>", line 1, in ?
	KeyError: 'name'
	而使用get不会这样：
	>>> print(d.get('name'))
	None
	如你所见，使用get来访问不存在的键时，没有引发异常，而是返回None。你可指定“默认”值，这样将返回你指定的值而不是None。
	>>> d.get('name', 'N/A')
	'N/A'
	如果字典包含指定的键， get的作用将与普通字典查找相同。
	>>> d['name'] = 'Eric'
	>>> d.get('name')
	'Eric

5. items
	方法items返回一个包含所有字典项的列表，其中每个元素都为(key, value)的形式。字典项
	在列表中的排列顺序不确定。
	>>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0}
	>>> d.items()
	dict_items([('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')])
	返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代（迭代将在第5章详细介绍）。
	另外，你还可确定其长度以及对其执行成员资格检查。
	>>> it = d.items()
	>>> len(it)
	3
	>>> ('spam', 0) in it
	True
	视图的一个优点是不复制，它们始终是底层字典的反映，即便你修改了底层字典亦如此。
	>>> d['spam'] = 1
	>>> ('spam', 0) in it
	False
	>>> d['spam'] = 0
	>>> ('spam', 0) in it
	True
	然而，如果你要将字典项复制到列表中（在较旧的Python版本中，方法items就是这样做的），
	可自己动手做。
	>>> list(d.items())
	[('spam', 0), ('title', 'Python Web Site'), ('url', 'http://www.python.org')]

6. keys
	方法keys返回一个字典视图，其中包含指定字典中的键。
	
7. values
	方法values返回一个由字典中的值组成的字典视图。不同于方法keys，方法values返回的视图可能包含重复的值。
		>>> d = {}
		>>> d[1] = 1
		>>> d[2] = 2
		>>> d[3] = 3
		>>> d[4] = 1
		>>> d.values()
		dict_values([1, 2, 3, 1])	
		
8. pop
	方法pop可用于获取与指定键相关联的值，并将该键值对从字典中删除。
	>>> d = {'x': 1, 'y': 2}
	>>> d.pop('x')
	1
	>>> d
	{'y': 2}
	
9. popitem
	方法popitem类似于list.pop，但list.pop弹出列表中的最后一个元素，而popitem随机地出一个字典项，因为字典项的顺序是不确定的，
	没有“最后一个元素”的概念。如果你要以高效地方式逐个删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。
	>>> d = {'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'}
	>>> d.popitem()
	('url', 'http://www.python.org')
	>>> d
	{'spam': 0, 'title': 'Python Web Site'}
	虽然popitem类似于列表方法pop，但字典没有与append（它在列表末尾添加一个元素）对应的方法。这是因为字典是无序的，类似的方法毫无意义。

10. setdefault
	方法setdefault有点像get，因为它也获取与指定键相关联的值，但除此之外， setdefault还在字典不包含指定的键时，在字典中添加指定的键值对。
	>>> d = {}
	>>> d.setdefault('name', 'N/A')
	'N/A'
	>>> d
	{'name': 'N/A'}
	>>> d['name'] = 'Gumby'
	>>> d.setdefault('name', 'N/A')
	'Gumby'
	>>> d
	{'name': 'Gumby'}
	如你所见，指定的键不存在时， setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与get一样，值是可选的；如果没有指定，默认为None。
	>>> d = {}
	>>> print(d.setdefault('name'))
	None
	>>> d
	{'name': None}
	
11. update
	方法update使用一个字典中的项来更新另一个字典。
	>>> d = {
	... 'title': 'Python Web Site',
	... 'url': 'http://www.python.org',
	... 'changed': 'Mar 14 22:09:15 MET 2016'
	... }	
	>>> x = {'title': 'Python Language Website'}
	>>> d.update(x)
	>>> d
	{'url': 'http://www.python.org', 'changed':
	'Mar 14 22:09:15 MET 2016', 'title': 'Python Language Website'}
	对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。
	可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键值对组成的序列（或其他可迭代对象）或关键字参数。

	friends = {'lxx': {'phone': 18888888888, 'addr': 'beijing'}, 'zwj': {'phone': 18010622207, 'addr': 'chengdu'}, 'hjj': {'phone': 18981808976, 'addr': 'chengdu'}}
	zwj_phone = friends['zwj']['phone']

第5章 条件、循环及其他语句

5.1 再谈 print 和 import

5.1.1 打印多个参数
		>>> print('Age:', 42)
		Age: 42
	
		>>> name = 'Gumby'
		>>> salutation = 'Mr.'
		>>> greeting = 'Hello,'
		>>> print(greeting, salutation, name)
		Hello, Mr. Gumby
		
5.1.2 导入时重命名
		>>> import math as foobar
		>>> foobar.sqrt(4)
		2.0
	下面是一个导入特定函数并给它指定别名的例子：
		>>> from math import sqrt as foobar
		>>> foobar(4)
		2.0	
		
5.2 赋值魔法		
		
5.2.1 序列解包	

	>>> x, y, z = 1, 2, 3
	>>> print(x, y, z)
	1 2 3		
		
	这在使用返回元组（或其他序列或可迭代对象）的函数或方法时很有用。假设要从字典中随便获取（或删除）一个键值对，
	可使用方法popitem，它随便获取一个键值对并以元组的方式返回。接下来，可直接将返回的元组解包到两个变量中。
	>>> scoundrel = {'name': 'Robin', 'girlfriend': 'Marion'}
	>>> key, value = scoundrel.popitem()
	>>> key
	'girlfriend'
	>>> value
	'Marion'		

	这让函数能够返回被打包成元组的多个值，然后通过一条赋值语句轻松地访问这些值。
	要解包的序列包含的元素个数必须与你在等号左边列出的目标个数相同，否则Python将引发异常。
	
	
	可使用星号运算符（*）来收集多余的值，这样无需确保值和变量的个数相同，如下例所示：
		>>> a, b, *rest = [1, 2, 3, 4]
		>>> rest
		[3, 4]
		
	还可将带星号的变量放在其他位置。
		>>> name = "Albus Percival Wulfric Brian Dumbledore"
		>>> first, *middle, last = name.split()
		>>> middle
		['Percival', 'Wulfric', 'Brian']		
		
	赋值语句的右边可以是任何类型的序列，但带星号的变量最终包含的总是一个列表。在变量和值的个数相同时亦如此。
	>>> a, *b, c = "abc"
	>>> a, b, c
	('a', ['b'], 'c')
	这种收集方式也可用于函数参数列表中		
	
5.2.2 链式赋值
	链式赋值是一种快捷方式，用于将多个变量关联到同一个值。这有点像前一节介绍的并行赋值，但只涉及一个值：
		x = y = somefunction()
	上述代码与下面的代码等价：
		y = somefunction()
		x = y
		
5.2.3 增强赋值
	可以不编写代码x = x + 1，而将右边表达式中的运算符（这里是+）移到赋值运算符（=）的前面，从而写成x += 1。这称为增强赋值，适用于所有标准运算符，如*、 /、 %等。
		>>> x = 2
		>>> x += 1
		>>> x *= 2
		>>> x
		6

	增强赋值也可用于其他数据类型（只要使用的双目运算符可用于这些数据类型）。
		>>> fnord = 'foo'
		>>> fnord += 'bar'
		>>> fnord *= 2
		>>> fnord
		'foobarfoobar'
	通过使用增强赋值，可让代码更紧凑、更简洁，同时在很多情况下的可读性更强。
	
5.3 代码块：缩进的乐趣	

5.4 条件和条件语句
	name = input('What is your name?')
	if name.endswith('Gumby'):
		print('Hello, Mr. Gumby')
	else:
		print('Hello, stranger')
				
	num = int(iut("Please enter a number:"))
	f num > 0:
		print("{} is positive".format(num))
	elif num == 0:
		print("{} is 0".format(num))
	else:
		print("{} is negtive",foramt(num))
		
5.4.5 代码块嵌套
	下面穿插点额外的内容。你可将if语句放在其他if语句块中，如下所示：
		name = input('What is your name? ')
		if name.endswith('Gumby'):
			if name.startswith('Mr.'):
				print('Hello, Mr. Gumby')
			elif name.startswith('Mrs.'):
				print('Hello, Mrs. Gumby')
			else:
				print('Hello, Gumby')
		else:
			print('Hello, stranger')		
		
5.4.6 更复杂的条件

1. 比较运算符
	在条件表达式中，最基本的运算符可能是比较运算符，它们用于执行比较。表5-1对比较运算符做了总结。
				表5-1 Python比较运算符
	--------------------------------------------------------------------
	表达式  			描 述
	--------------------------------------------------------------------
	x == y 			x 等于y
	x < y 			x小于y
	x > y 			x大于y
	x >= y 			x大于或等于y
	x <= y 			x小于或等于y
	x != y 			x不等于y
	x is y 			x和y是同一个对象
	x is not y 		x和y是不同的对象
	x in y 			x是容器（如序列） y的成员
	x not in 		y x不是容器（如序列） y的成员	
	
	注意: ==用来检查两个对象是否相等，而is用来检查两个对象是否相同（是同一个对象）。
	
	在Python 3中，已经不允许这样比较不兼容的类型了。
	
	与赋值一样， Python也支持链式比较：可同时使用多个比较运算符，如0 < age < 100。	
	
	有些比较运算符需要特别注意，下面就来详细介绍。
	
	1) 相等运算符
		要确定两个对象是否相等，可使用比较运算符，用两个等号（==）表示。
		>>> "foo" == "foo"
		True
		>>> "foo" == "bar"
		False
		两个等号？为何不像数学中那样使用一个等号呢？相信你很聪明，自己就能够明白其中的原因，但这里还是试试一个等号吧。
		>>> "foo" = "foo"
		SyntaxError: can't assign to literal	
		
		一个等号是赋值运算符，用于修改值，而进行比较时你可不想这样做。
		
	2)is：相同运算符 这个运算符很有趣，其作用看似与==一样，但实际上并非如此。
		>>> x = y = [1, 2, 3]
		>>> z = [1, 2, 3]
		>>> x == y
		True
		>>> x == z
		True
		>>> x is y
		True
		>>> x is z
		False		
	
	因为is检查两个对象是否相同（而不是相等） 。变量x和y指向同一个列表，而z指向另一个列表
	（其中包含的值以及这些值的排列顺序都与前一个列表相同） 。这两个列表虽然相等，但并非同一个对象。
	
	3)in：成员资格运算符
		运算符in在2.2.5节介绍过，与其他比较运算符一样，它也可用于条件表达式中。
		
		name = input('What is your name?')
		if 's' in name:
			print('Your name contains the letter "s".')
		else:
			print('Your name does not contain the letter "s".')
		
	4)字符串和序列的比较
		字符串是根据字符的字母排列顺序进行比较的。
			>>> "alpha" < "beta"
			True

		虽然基于的是字母排列顺序，但字母都是Unicode字符，它们是按码点排列的。	
		
2. 布尔运算符

	number = int(input('Enter a number between 1 and 10: '))
	if 1 <= number <= 10:
		print('Great!')
	else:
		print('Wrong!')
	
5.4.7 断言
	
如果知道必须满足特定条件，程序才能正确地运行，可在程序中添加assert语句充当检查点，这很有帮助。还可在条件后面添加一个字符串，对断言做出说明。
	>>> age = -1
	>>> assert 0 < age < 100, 'The age must be realistic'
	Traceback (most recent call last):
	File "<stdin>", line 1, in ?
	AssertionError: The age must be realistic	
	
5.5 循环	
	
5.5.1 while 循环
	为避免前述示例所示的繁琐代码，能够像下面这样做很有帮助：
		x = 1
		while x <= 100:
		print(x)
		x += 1	
		
		
5.5.2 for 循环
	基本上， 可迭代对象是可使用for循环进行遍历的对象。第9章将详细介绍可迭代对象和迭代器。就目前而言，只需将可迭代对象视为序列即可

	words = ['this', 'is', 'an', 'ex', 'parrot']
	for word in words:
	print(word)
或
	numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	for number in numbers:
	print(number)
	
	鉴于迭代（也就是遍历）特定范围内的数是一种常见的任务， Python提供了一个创建范围的内置函数。
	
	>>> range(0, 10)
	range(0, 10)
	>>> list(range(0, 10))
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	
	范围类似于切片。它们包含起始位置（这里为0），但不包含结束位置（这里为10） 。在很多情况下，你都希望范围的起始位置为0。
	实际上，如果只提供了一个位置，将把这个位置视为结束位置，并假定起始位置为0。
		>>> range(10)
		range(0, 10)
		
	下面的程序打印数1～100：
		for number in range(1,101):
			print(number)
			
		sum = 0
		hundreds = list(range(1, 101))
		for i in range(0, len(hundreds)):
			sum = sum + hundreds[i]

		print(sum)
			
5.5.3 迭代字典
	

	
	